// automatically generated by the FlatBuffers compiler, do not modify



use crate::types_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod wamp {

  use crate::types_generated::*;
  use crate::types_generated::wamp::proto::Match;
  use crate::types_generated::wamp::proto::Serializer;
  use crate::types_generated::wamp::proto::Payload;
  use crate::types_generated::wamp::proto::CancelMode;
  use crate::types_generated::wamp::proto::InvocationPolicy;
  use crate::types_generated::wamp::proto::Principal;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod proto {

  use crate::types_generated::*;
  use crate::types_generated::wamp::proto::Match;
  use crate::types_generated::wamp::proto::Serializer;
  use crate::types_generated::wamp::proto::Payload;
  use crate::types_generated::wamp::proto::CancelMode;
  use crate::types_generated::wamp::proto::InvocationPolicy;
  use crate::types_generated::wamp::proto::Principal;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum CallOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Call<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Call<'a> {
  type Inner = Call<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Call<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_PROCEDURE: flatbuffers::VOffsetT = 6;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;
  pub const VT_ENC_ALGO: flatbuffers::VOffsetT = 10;
  pub const VT_ENC_SERIALIZER: flatbuffers::VOffsetT = 12;
  pub const VT_ENC_KEY: flatbuffers::VOffsetT = 14;
  pub const VT_TIMEOUT: flatbuffers::VOffsetT = 16;
  pub const VT_RECEIVE_PROGRESS: flatbuffers::VOffsetT = 18;
  pub const VT_TRANSACTION_HASH: flatbuffers::VOffsetT = 20;
  pub const VT_CALLER: flatbuffers::VOffsetT = 22;
  pub const VT_CALLER_AUTHID: flatbuffers::VOffsetT = 24;
  pub const VT_CALLER_AUTHROLE: flatbuffers::VOffsetT = 26;
  pub const VT_FORWARD_FOR: flatbuffers::VOffsetT = 28;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Call { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CallArgs<'args>
  ) -> flatbuffers::WIPOffset<Call<'bldr>> {
    let mut builder = CallBuilder::new(_fbb);
    builder.add_caller(args.caller);
    builder.add_request(args.request);
    if let Some(x) = args.forward_for { builder.add_forward_for(x); }
    if let Some(x) = args.caller_authrole { builder.add_caller_authrole(x); }
    if let Some(x) = args.caller_authid { builder.add_caller_authid(x); }
    if let Some(x) = args.transaction_hash { builder.add_transaction_hash(x); }
    builder.add_timeout(args.timeout);
    if let Some(x) = args.enc_key { builder.add_enc_key(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.procedure { builder.add_procedure(x); }
    builder.add_receive_progress(args.receive_progress);
    builder.add_enc_serializer(args.enc_serializer);
    builder.add_enc_algo(args.enc_algo);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Call::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Call) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn procedure(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Call::VT_PROCEDURE, None).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Call::VT_PAYLOAD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn enc_algo(&self) -> Payload {
    self._tab.get::<Payload>(Call::VT_ENC_ALGO, Some(Payload::PLAIN)).unwrap()
  }
  #[inline]
  pub fn enc_serializer(&self) -> Serializer {
    self._tab.get::<Serializer>(Call::VT_ENC_SERIALIZER, Some(Serializer::TRANSPORT)).unwrap()
  }
  #[inline]
  pub fn enc_key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Call::VT_ENC_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn timeout(&self) -> u32 {
    self._tab.get::<u32>(Call::VT_TIMEOUT, Some(0)).unwrap()
  }
  #[inline]
  pub fn receive_progress(&self) -> bool {
    self._tab.get::<bool>(Call::VT_RECEIVE_PROGRESS, Some(false)).unwrap()
  }
  #[inline]
  pub fn transaction_hash(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Call::VT_TRANSACTION_HASH, None)
  }
  #[inline]
  pub fn caller(&self) -> u64 {
    self._tab.get::<u64>(Call::VT_CALLER, Some(0)).unwrap()
  }
  #[inline]
  pub fn caller_authid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Call::VT_CALLER_AUTHID, None)
  }
  #[inline]
  pub fn caller_authrole(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Call::VT_CALLER_AUTHROLE, None)
  }
  #[inline]
  pub fn forward_for(&self) -> Option<&'a [Principal]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Principal>>>(Call::VT_FORWARD_FOR, None).map(|v| v.safe_slice())
  }
}

/*
impl flatbuffers::Verifiable for Call<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("procedure", Self::VT_PROCEDURE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<Payload>("enc_algo", Self::VT_ENC_ALGO, false)?
     .visit_field::<Serializer>("enc_serializer", Self::VT_ENC_SERIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("enc_key", Self::VT_ENC_KEY, false)?
     .visit_field::<u32>("timeout", Self::VT_TIMEOUT, false)?
     .visit_field::<bool>("receive_progress", Self::VT_RECEIVE_PROGRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction_hash", Self::VT_TRANSACTION_HASH, false)?
     .visit_field::<u64>("caller", Self::VT_CALLER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("caller_authid", Self::VT_CALLER_AUTHID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("caller_authrole", Self::VT_CALLER_AUTHROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Principal>>>("forward_for", Self::VT_FORWARD_FOR, false)?
     .finish();
    Ok(())
  }
}
 */

pub struct CallArgs<'a> {
    pub request: u64,
    pub procedure: Option<flatbuffers::WIPOffset<&'a str>>,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub enc_algo: Payload,
    pub enc_serializer: Serializer,
    pub enc_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub timeout: u32,
    pub receive_progress: bool,
    pub transaction_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    pub caller: u64,
    pub caller_authid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub caller_authrole: Option<flatbuffers::WIPOffset<&'a str>>,
    pub forward_for: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Principal>>>,
}
impl<'a> Default for CallArgs<'a> {
  #[inline]
  fn default() -> Self {
    CallArgs {
      request: 0,
      procedure: None, // required field
      payload: None,
      enc_algo: Payload::PLAIN,
      enc_serializer: Serializer::TRANSPORT,
      enc_key: None,
      timeout: 0,
      receive_progress: false,
      transaction_hash: None,
      caller: 0,
      caller_authid: None,
      caller_authrole: None,
      forward_for: None,
    }
  }
}

pub struct CallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CallBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Call::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_procedure(&mut self, procedure: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Call::VT_PROCEDURE, procedure);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Call::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_enc_algo(&mut self, enc_algo: Payload) {
    self.fbb_.push_slot::<Payload>(Call::VT_ENC_ALGO, enc_algo, Payload::PLAIN);
  }
  #[inline]
  pub fn add_enc_serializer(&mut self, enc_serializer: Serializer) {
    self.fbb_.push_slot::<Serializer>(Call::VT_ENC_SERIALIZER, enc_serializer, Serializer::TRANSPORT);
  }
  #[inline]
  pub fn add_enc_key(&mut self, enc_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Call::VT_ENC_KEY, enc_key);
  }
  #[inline]
  pub fn add_timeout(&mut self, timeout: u32) {
    self.fbb_.push_slot::<u32>(Call::VT_TIMEOUT, timeout, 0);
  }
  #[inline]
  pub fn add_receive_progress(&mut self, receive_progress: bool) {
    self.fbb_.push_slot::<bool>(Call::VT_RECEIVE_PROGRESS, receive_progress, false);
  }
  #[inline]
  pub fn add_transaction_hash(&mut self, transaction_hash: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Call::VT_TRANSACTION_HASH, transaction_hash);
  }
  #[inline]
  pub fn add_caller(&mut self, caller: u64) {
    self.fbb_.push_slot::<u64>(Call::VT_CALLER, caller, 0);
  }
  #[inline]
  pub fn add_caller_authid(&mut self, caller_authid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Call::VT_CALLER_AUTHID, caller_authid);
  }
  #[inline]
  pub fn add_caller_authrole(&mut self, caller_authrole: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Call::VT_CALLER_AUTHROLE, caller_authrole);
  }
  #[inline]
  pub fn add_forward_for(&mut self, forward_for: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Principal>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Call::VT_FORWARD_FOR, forward_for);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Call<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Call::VT_PROCEDURE,"procedure");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Call<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Call");
      ds.field("request", &self.request());
      ds.field("procedure", &self.procedure());
      ds.field("payload", &self.payload());
      ds.field("enc_algo", &self.enc_algo());
      ds.field("enc_serializer", &self.enc_serializer());
      ds.field("enc_key", &self.enc_key());
      ds.field("timeout", &self.timeout());
      ds.field("receive_progress", &self.receive_progress());
      ds.field("transaction_hash", &self.transaction_hash());
      ds.field("caller", &self.caller());
      ds.field("caller_authid", &self.caller_authid());
      ds.field("caller_authrole", &self.caller_authrole());
      ds.field("forward_for", &self.forward_for());
      ds.finish()
  }
}
pub enum CancelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Cancel<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Cancel<'a> {
  type Inner = Cancel<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Cancel<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_MODE: flatbuffers::VOffsetT = 6;
  pub const VT_FORWARD_FOR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Cancel { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CancelArgs<'args>
  ) -> flatbuffers::WIPOffset<Cancel<'bldr>> {
    let mut builder = CancelBuilder::new(_fbb);
    builder.add_request(args.request);
    if let Some(x) = args.forward_for { builder.add_forward_for(x); }
    builder.add_mode(args.mode);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Cancel::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Cancel) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn mode(&self) -> CancelMode {
    self._tab.get::<CancelMode>(Cancel::VT_MODE, Some(CancelMode::SKIP)).unwrap()
  }
  #[inline]
  pub fn forward_for(&self) -> Option<&'a [Principal]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Principal>>>(Cancel::VT_FORWARD_FOR, None).map(|v| v.safe_slice())
  }
}

/*
impl flatbuffers::Verifiable for Cancel<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<CancelMode>("mode", Self::VT_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Principal>>>("forward_for", Self::VT_FORWARD_FOR, false)?
     .finish();
    Ok(())
  }
}
 */

pub struct CancelArgs<'a> {
    pub request: u64,
    pub mode: CancelMode,
    pub forward_for: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Principal>>>,
}
impl<'a> Default for CancelArgs<'a> {
  #[inline]
  fn default() -> Self {
    CancelArgs {
      request: 0,
      mode: CancelMode::SKIP,
      forward_for: None,
    }
  }
}

pub struct CancelBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CancelBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Cancel::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: CancelMode) {
    self.fbb_.push_slot::<CancelMode>(Cancel::VT_MODE, mode, CancelMode::SKIP);
  }
  #[inline]
  pub fn add_forward_for(&mut self, forward_for: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Principal>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Cancel::VT_FORWARD_FOR, forward_for);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CancelBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CancelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Cancel<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Cancel<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Cancel");
      ds.field("request", &self.request());
      ds.field("mode", &self.mode());
      ds.field("forward_for", &self.forward_for());
      ds.finish()
  }
}
pub enum ResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Result<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Result<'a> {
  type Inner = Result<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Result<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;
  pub const VT_ENC_ALGO: flatbuffers::VOffsetT = 8;
  pub const VT_ENC_SERIALIZER: flatbuffers::VOffsetT = 10;
  pub const VT_ENC_KEY: flatbuffers::VOffsetT = 12;
  pub const VT_PROGRESS: flatbuffers::VOffsetT = 14;
  pub const VT_CALLEE: flatbuffers::VOffsetT = 16;
  pub const VT_CALLEE_AUTHID: flatbuffers::VOffsetT = 18;
  pub const VT_CALLEE_AUTHROLE: flatbuffers::VOffsetT = 20;
  pub const VT_FORWARD_FOR: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Result { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ResultArgs<'args>
  ) -> flatbuffers::WIPOffset<Result<'bldr>> {
    let mut builder = ResultBuilder::new(_fbb);
    builder.add_callee(args.callee);
    builder.add_request(args.request);
    if let Some(x) = args.forward_for { builder.add_forward_for(x); }
    if let Some(x) = args.callee_authrole { builder.add_callee_authrole(x); }
    if let Some(x) = args.callee_authid { builder.add_callee_authid(x); }
    if let Some(x) = args.enc_key { builder.add_enc_key(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    builder.add_progress(args.progress);
    builder.add_enc_serializer(args.enc_serializer);
    builder.add_enc_algo(args.enc_algo);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Result::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Result) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn payload(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Result::VT_PAYLOAD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn enc_algo(&self) -> Payload {
    self._tab.get::<Payload>(Result::VT_ENC_ALGO, Some(Payload::PLAIN)).unwrap()
  }
  #[inline]
  pub fn enc_serializer(&self) -> Serializer {
    self._tab.get::<Serializer>(Result::VT_ENC_SERIALIZER, Some(Serializer::TRANSPORT)).unwrap()
  }
  #[inline]
  pub fn enc_key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Result::VT_ENC_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn progress(&self) -> bool {
    self._tab.get::<bool>(Result::VT_PROGRESS, Some(false)).unwrap()
  }
  #[inline]
  pub fn callee(&self) -> u64 {
    self._tab.get::<u64>(Result::VT_CALLEE, Some(0)).unwrap()
  }
  #[inline]
  pub fn callee_authid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Result::VT_CALLEE_AUTHID, None)
  }
  #[inline]
  pub fn callee_authrole(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Result::VT_CALLEE_AUTHROLE, None)
  }
  #[inline]
  pub fn forward_for(&self) -> Option<&'a [Principal]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Principal>>>(Result::VT_FORWARD_FOR, None).map(|v| v.safe_slice())
  }
}

/*
impl flatbuffers::Verifiable for Result<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<Payload>("enc_algo", Self::VT_ENC_ALGO, false)?
     .visit_field::<Serializer>("enc_serializer", Self::VT_ENC_SERIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("enc_key", Self::VT_ENC_KEY, false)?
     .visit_field::<bool>("progress", Self::VT_PROGRESS, false)?
     .visit_field::<u64>("callee", Self::VT_CALLEE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callee_authid", Self::VT_CALLEE_AUTHID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callee_authrole", Self::VT_CALLEE_AUTHROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Principal>>>("forward_for", Self::VT_FORWARD_FOR, false)?
     .finish();
    Ok(())
  }
}
 */

pub struct ResultArgs<'a> {
    pub request: u64,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub enc_algo: Payload,
    pub enc_serializer: Serializer,
    pub enc_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub progress: bool,
    pub callee: u64,
    pub callee_authid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub callee_authrole: Option<flatbuffers::WIPOffset<&'a str>>,
    pub forward_for: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Principal>>>,
}
impl<'a> Default for ResultArgs<'a> {
  #[inline]
  fn default() -> Self {
    ResultArgs {
      request: 0,
      payload: None,
      enc_algo: Payload::PLAIN,
      enc_serializer: Serializer::TRANSPORT,
      enc_key: None,
      progress: false,
      callee: 0,
      callee_authid: None,
      callee_authrole: None,
      forward_for: None,
    }
  }
}

pub struct ResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Result::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Result::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_enc_algo(&mut self, enc_algo: Payload) {
    self.fbb_.push_slot::<Payload>(Result::VT_ENC_ALGO, enc_algo, Payload::PLAIN);
  }
  #[inline]
  pub fn add_enc_serializer(&mut self, enc_serializer: Serializer) {
    self.fbb_.push_slot::<Serializer>(Result::VT_ENC_SERIALIZER, enc_serializer, Serializer::TRANSPORT);
  }
  #[inline]
  pub fn add_enc_key(&mut self, enc_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Result::VT_ENC_KEY, enc_key);
  }
  #[inline]
  pub fn add_progress(&mut self, progress: bool) {
    self.fbb_.push_slot::<bool>(Result::VT_PROGRESS, progress, false);
  }
  #[inline]
  pub fn add_callee(&mut self, callee: u64) {
    self.fbb_.push_slot::<u64>(Result::VT_CALLEE, callee, 0);
  }
  #[inline]
  pub fn add_callee_authid(&mut self, callee_authid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Result::VT_CALLEE_AUTHID, callee_authid);
  }
  #[inline]
  pub fn add_callee_authrole(&mut self, callee_authrole: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Result::VT_CALLEE_AUTHROLE, callee_authrole);
  }
  #[inline]
  pub fn add_forward_for(&mut self, forward_for: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Principal>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Result::VT_FORWARD_FOR, forward_for);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Result<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Result<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Result");
      ds.field("request", &self.request());
      ds.field("payload", &self.payload());
      ds.field("enc_algo", &self.enc_algo());
      ds.field("enc_serializer", &self.enc_serializer());
      ds.field("enc_key", &self.enc_key());
      ds.field("progress", &self.progress());
      ds.field("callee", &self.callee());
      ds.field("callee_authid", &self.callee_authid());
      ds.field("callee_authrole", &self.callee_authrole());
      ds.field("forward_for", &self.forward_for());
      ds.finish()
  }
}
pub enum RegisterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Register<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Register<'a> {
  type Inner = Register<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Register<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_PROCEDURE: flatbuffers::VOffsetT = 6;
  pub const VT_MATCH_: flatbuffers::VOffsetT = 8;
  pub const VT_INVOKE: flatbuffers::VOffsetT = 10;
  pub const VT_CONCURRENCY: flatbuffers::VOffsetT = 12;
  pub const VT_FORCE_REREGISTER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Register { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RegisterArgs<'args>
  ) -> flatbuffers::WIPOffset<Register<'bldr>> {
    let mut builder = RegisterBuilder::new(_fbb);
    builder.add_request(args.request);
    if let Some(x) = args.procedure { builder.add_procedure(x); }
    builder.add_concurrency(args.concurrency);
    builder.add_force_reregister(args.force_reregister);
    builder.add_invoke(args.invoke);
    builder.add_match_(args.match_);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Register::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Register) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn procedure(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Register::VT_PROCEDURE, None).unwrap()
  }
  #[inline]
  pub fn match_(&self) -> Match {
    self._tab.get::<Match>(Register::VT_MATCH_, Some(Match::EXACT)).unwrap()
  }
  #[inline]
  pub fn invoke(&self) -> InvocationPolicy {
    self._tab.get::<InvocationPolicy>(Register::VT_INVOKE, Some(InvocationPolicy::SINGLE)).unwrap()
  }
  #[inline]
  pub fn concurrency(&self) -> u16 {
    self._tab.get::<u16>(Register::VT_CONCURRENCY, Some(0)).unwrap()
  }
  #[inline]
  pub fn force_reregister(&self) -> bool {
    self._tab.get::<bool>(Register::VT_FORCE_REREGISTER, Some(false)).unwrap()
  }
}

/*
impl flatbuffers::Verifiable for Register<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("procedure", Self::VT_PROCEDURE, true)?
     .visit_field::<Match>("match_", Self::VT_MATCH_, false)?
     .visit_field::<InvocationPolicy>("invoke", Self::VT_INVOKE, false)?
     .visit_field::<u16>("concurrency", Self::VT_CONCURRENCY, false)?
     .visit_field::<bool>("force_reregister", Self::VT_FORCE_REREGISTER, false)?
     .finish();
    Ok(())
  }
}
 */

pub struct RegisterArgs<'a> {
    pub request: u64,
    pub procedure: Option<flatbuffers::WIPOffset<&'a str>>,
    pub match_: Match,
    pub invoke: InvocationPolicy,
    pub concurrency: u16,
    pub force_reregister: bool,
}
impl<'a> Default for RegisterArgs<'a> {
  #[inline]
  fn default() -> Self {
    RegisterArgs {
      request: 0,
      procedure: None, // required field
      match_: Match::EXACT,
      invoke: InvocationPolicy::SINGLE,
      concurrency: 0,
      force_reregister: false,
    }
  }
}

pub struct RegisterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RegisterBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Register::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_procedure(&mut self, procedure: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Register::VT_PROCEDURE, procedure);
  }
  #[inline]
  pub fn add_match_(&mut self, match_: Match) {
    self.fbb_.push_slot::<Match>(Register::VT_MATCH_, match_, Match::EXACT);
  }
  #[inline]
  pub fn add_invoke(&mut self, invoke: InvocationPolicy) {
    self.fbb_.push_slot::<InvocationPolicy>(Register::VT_INVOKE, invoke, InvocationPolicy::SINGLE);
  }
  #[inline]
  pub fn add_concurrency(&mut self, concurrency: u16) {
    self.fbb_.push_slot::<u16>(Register::VT_CONCURRENCY, concurrency, 0);
  }
  #[inline]
  pub fn add_force_reregister(&mut self, force_reregister: bool) {
    self.fbb_.push_slot::<bool>(Register::VT_FORCE_REREGISTER, force_reregister, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RegisterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RegisterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Register<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Register::VT_PROCEDURE,"procedure");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Register<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Register");
      ds.field("request", &self.request());
      ds.field("procedure", &self.procedure());
      ds.field("match_", &self.match_());
      ds.field("invoke", &self.invoke());
      ds.field("concurrency", &self.concurrency());
      ds.field("force_reregister", &self.force_reregister());
      ds.finish()
  }
}
pub enum RegisteredOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Registered<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Registered<'a> {
  type Inner = Registered<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Registered<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_REGISTRATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Registered { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RegisteredArgs
  ) -> flatbuffers::WIPOffset<Registered<'bldr>> {
    let mut builder = RegisteredBuilder::new(_fbb);
    builder.add_registration(args.registration);
    builder.add_request(args.request);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Registered::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Registered) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn registration(&self) -> u64 {
    self._tab.get::<u64>(Registered::VT_REGISTRATION, Some(0)).unwrap()
  }
}

/*
impl flatbuffers::Verifiable for Registered<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<u64>("registration", Self::VT_REGISTRATION, false)?
     .finish();
    Ok(())
  }
}
 */

pub struct RegisteredArgs {
    pub request: u64,
    pub registration: u64,
}
impl<'a> Default for RegisteredArgs {
  #[inline]
  fn default() -> Self {
    RegisteredArgs {
      request: 0,
      registration: 0,
    }
  }
}

pub struct RegisteredBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RegisteredBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Registered::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_registration(&mut self, registration: u64) {
    self.fbb_.push_slot::<u64>(Registered::VT_REGISTRATION, registration, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RegisteredBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RegisteredBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Registered<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Registered<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Registered");
      ds.field("request", &self.request());
      ds.field("registration", &self.registration());
      ds.finish()
  }
}
pub enum UnregisterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Unregister<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Unregister<'a> {
  type Inner = Unregister<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Unregister<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_REGISTRATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Unregister { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnregisterArgs
  ) -> flatbuffers::WIPOffset<Unregister<'bldr>> {
    let mut builder = UnregisterBuilder::new(_fbb);
    builder.add_registration(args.registration);
    builder.add_request(args.request);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Unregister::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Unregister) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn registration(&self) -> u64 {
    self._tab.get::<u64>(Unregister::VT_REGISTRATION, Some(0)).unwrap()
  }
}

/*
impl flatbuffers::Verifiable for Unregister<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<u64>("registration", Self::VT_REGISTRATION, false)?
     .finish();
    Ok(())
  }
}
 */
pub struct UnregisterArgs {
    pub request: u64,
    pub registration: u64,
}
impl<'a> Default for UnregisterArgs {
  #[inline]
  fn default() -> Self {
    UnregisterArgs {
      request: 0,
      registration: 0,
    }
  }
}

pub struct UnregisterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnregisterBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Unregister::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_registration(&mut self, registration: u64) {
    self.fbb_.push_slot::<u64>(Unregister::VT_REGISTRATION, registration, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnregisterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnregisterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Unregister<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Unregister<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Unregister");
      ds.field("request", &self.request());
      ds.field("registration", &self.registration());
      ds.finish()
  }
}
pub enum UnregisteredOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Unregistered<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Unregistered<'a> {
  type Inner = Unregistered<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Unregistered<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_REGISTRATION: flatbuffers::VOffsetT = 6;
  pub const VT_REASON: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Unregistered { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnregisteredArgs<'args>
  ) -> flatbuffers::WIPOffset<Unregistered<'bldr>> {
    let mut builder = UnregisteredBuilder::new(_fbb);
    builder.add_registration(args.registration);
    builder.add_request(args.request);
    if let Some(x) = args.reason { builder.add_reason(x); }
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Unregistered::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Unregistered) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn registration(&self) -> u64 {
    self._tab.get::<u64>(Unregistered::VT_REGISTRATION, Some(0)).unwrap()
  }
  #[inline]
  pub fn reason(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Unregistered::VT_REASON, None)
  }
}

/*
impl flatbuffers::Verifiable for Unregistered<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<u64>("registration", Self::VT_REGISTRATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reason", Self::VT_REASON, false)?
     .finish();
    Ok(())
  }
}
 */

pub struct UnregisteredArgs<'a> {
    pub request: u64,
    pub registration: u64,
    pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UnregisteredArgs<'a> {
  #[inline]
  fn default() -> Self {
    UnregisteredArgs {
      request: 0,
      registration: 0,
      reason: None,
    }
  }
}

pub struct UnregisteredBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnregisteredBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Unregistered::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_registration(&mut self, registration: u64) {
    self.fbb_.push_slot::<u64>(Unregistered::VT_REGISTRATION, registration, 0);
  }
  #[inline]
  pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Unregistered::VT_REASON, reason);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnregisteredBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnregisteredBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Unregistered<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Unregistered<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Unregistered");
      ds.field("request", &self.request());
      ds.field("registration", &self.registration());
      ds.field("reason", &self.reason());
      ds.finish()
  }
}
pub enum InvocationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Invocation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Invocation<'a> {
  type Inner = Invocation<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Invocation<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_REGISTRATION: flatbuffers::VOffsetT = 6;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 8;
  pub const VT_ENC_ALGO: flatbuffers::VOffsetT = 10;
  pub const VT_ENC_SERIALIZER: flatbuffers::VOffsetT = 12;
  pub const VT_ENC_KEY: flatbuffers::VOffsetT = 14;
  pub const VT_PROCEDURE: flatbuffers::VOffsetT = 16;
  pub const VT_TIMEOUT: flatbuffers::VOffsetT = 18;
  pub const VT_RECEIVE_PROGRESS: flatbuffers::VOffsetT = 20;
  pub const VT_TRANSACTION_HASH: flatbuffers::VOffsetT = 22;
  pub const VT_CALLER: flatbuffers::VOffsetT = 24;
  pub const VT_CALLER_AUTHID: flatbuffers::VOffsetT = 26;
  pub const VT_CALLER_AUTHROLE: flatbuffers::VOffsetT = 28;
  pub const VT_FORWARD_FOR: flatbuffers::VOffsetT = 30;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Invocation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args InvocationArgs<'args>
  ) -> flatbuffers::WIPOffset<Invocation<'bldr>> {
    let mut builder = InvocationBuilder::new(_fbb);
    builder.add_caller(args.caller);
    builder.add_registration(args.registration);
    builder.add_request(args.request);
    if let Some(x) = args.forward_for { builder.add_forward_for(x); }
    if let Some(x) = args.caller_authrole { builder.add_caller_authrole(x); }
    if let Some(x) = args.caller_authid { builder.add_caller_authid(x); }
    if let Some(x) = args.transaction_hash { builder.add_transaction_hash(x); }
    builder.add_timeout(args.timeout);
    if let Some(x) = args.procedure { builder.add_procedure(x); }
    if let Some(x) = args.enc_key { builder.add_enc_key(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    builder.add_receive_progress(args.receive_progress);
    builder.add_enc_serializer(args.enc_serializer);
    builder.add_enc_algo(args.enc_algo);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Invocation::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Invocation) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn registration(&self) -> u64 {
    self._tab.get::<u64>(Invocation::VT_REGISTRATION, Some(0)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Invocation::VT_PAYLOAD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn enc_algo(&self) -> Payload {
    self._tab.get::<Payload>(Invocation::VT_ENC_ALGO, Some(Payload::PLAIN)).unwrap()
  }
  #[inline]
  pub fn enc_serializer(&self) -> Serializer {
    self._tab.get::<Serializer>(Invocation::VT_ENC_SERIALIZER, Some(Serializer::TRANSPORT)).unwrap()
  }
  #[inline]
  pub fn enc_key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Invocation::VT_ENC_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn procedure(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Invocation::VT_PROCEDURE, None)
  }
  #[inline]
  pub fn timeout(&self) -> u32 {
    self._tab.get::<u32>(Invocation::VT_TIMEOUT, Some(0)).unwrap()
  }
  #[inline]
  pub fn receive_progress(&self) -> bool {
    self._tab.get::<bool>(Invocation::VT_RECEIVE_PROGRESS, Some(false)).unwrap()
  }
  #[inline]
  pub fn transaction_hash(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Invocation::VT_TRANSACTION_HASH, None)
  }
  #[inline]
  pub fn caller(&self) -> u64 {
    self._tab.get::<u64>(Invocation::VT_CALLER, Some(0)).unwrap()
  }
  #[inline]
  pub fn caller_authid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Invocation::VT_CALLER_AUTHID, None)
  }
  #[inline]
  pub fn caller_authrole(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Invocation::VT_CALLER_AUTHROLE, None)
  }
  #[inline]
  pub fn forward_for(&self) -> Option<&'a [Principal]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Principal>>>(Invocation::VT_FORWARD_FOR, None).map(|v| v.safe_slice())
  }
}

/*
impl flatbuffers::Verifiable for Invocation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<u64>("registration", Self::VT_REGISTRATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<Payload>("enc_algo", Self::VT_ENC_ALGO, false)?
     .visit_field::<Serializer>("enc_serializer", Self::VT_ENC_SERIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("enc_key", Self::VT_ENC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("procedure", Self::VT_PROCEDURE, false)?
     .visit_field::<u32>("timeout", Self::VT_TIMEOUT, false)?
     .visit_field::<bool>("receive_progress", Self::VT_RECEIVE_PROGRESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction_hash", Self::VT_TRANSACTION_HASH, false)?
     .visit_field::<u64>("caller", Self::VT_CALLER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("caller_authid", Self::VT_CALLER_AUTHID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("caller_authrole", Self::VT_CALLER_AUTHROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Principal>>>("forward_for", Self::VT_FORWARD_FOR, false)?
     .finish();
    Ok(())
  }
}
 */

pub struct InvocationArgs<'a> {
    pub request: u64,
    pub registration: u64,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub enc_algo: Payload,
    pub enc_serializer: Serializer,
    pub enc_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub procedure: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timeout: u32,
    pub receive_progress: bool,
    pub transaction_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    pub caller: u64,
    pub caller_authid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub caller_authrole: Option<flatbuffers::WIPOffset<&'a str>>,
    pub forward_for: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Principal>>>,
}
impl<'a> Default for InvocationArgs<'a> {
  #[inline]
  fn default() -> Self {
    InvocationArgs {
      request: 0,
      registration: 0,
      payload: None,
      enc_algo: Payload::PLAIN,
      enc_serializer: Serializer::TRANSPORT,
      enc_key: None,
      procedure: None,
      timeout: 0,
      receive_progress: false,
      transaction_hash: None,
      caller: 0,
      caller_authid: None,
      caller_authrole: None,
      forward_for: None,
    }
  }
}

pub struct InvocationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InvocationBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Invocation::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_registration(&mut self, registration: u64) {
    self.fbb_.push_slot::<u64>(Invocation::VT_REGISTRATION, registration, 0);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Invocation::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_enc_algo(&mut self, enc_algo: Payload) {
    self.fbb_.push_slot::<Payload>(Invocation::VT_ENC_ALGO, enc_algo, Payload::PLAIN);
  }
  #[inline]
  pub fn add_enc_serializer(&mut self, enc_serializer: Serializer) {
    self.fbb_.push_slot::<Serializer>(Invocation::VT_ENC_SERIALIZER, enc_serializer, Serializer::TRANSPORT);
  }
  #[inline]
  pub fn add_enc_key(&mut self, enc_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Invocation::VT_ENC_KEY, enc_key);
  }
  #[inline]
  pub fn add_procedure(&mut self, procedure: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Invocation::VT_PROCEDURE, procedure);
  }
  #[inline]
  pub fn add_timeout(&mut self, timeout: u32) {
    self.fbb_.push_slot::<u32>(Invocation::VT_TIMEOUT, timeout, 0);
  }
  #[inline]
  pub fn add_receive_progress(&mut self, receive_progress: bool) {
    self.fbb_.push_slot::<bool>(Invocation::VT_RECEIVE_PROGRESS, receive_progress, false);
  }
  #[inline]
  pub fn add_transaction_hash(&mut self, transaction_hash: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Invocation::VT_TRANSACTION_HASH, transaction_hash);
  }
  #[inline]
  pub fn add_caller(&mut self, caller: u64) {
    self.fbb_.push_slot::<u64>(Invocation::VT_CALLER, caller, 0);
  }
  #[inline]
  pub fn add_caller_authid(&mut self, caller_authid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Invocation::VT_CALLER_AUTHID, caller_authid);
  }
  #[inline]
  pub fn add_caller_authrole(&mut self, caller_authrole: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Invocation::VT_CALLER_AUTHROLE, caller_authrole);
  }
  #[inline]
  pub fn add_forward_for(&mut self, forward_for: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Principal>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Invocation::VT_FORWARD_FOR, forward_for);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InvocationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InvocationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Invocation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Invocation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Invocation");
      ds.field("request", &self.request());
      ds.field("registration", &self.registration());
      ds.field("payload", &self.payload());
      ds.field("enc_algo", &self.enc_algo());
      ds.field("enc_serializer", &self.enc_serializer());
      ds.field("enc_key", &self.enc_key());
      ds.field("procedure", &self.procedure());
      ds.field("timeout", &self.timeout());
      ds.field("receive_progress", &self.receive_progress());
      ds.field("transaction_hash", &self.transaction_hash());
      ds.field("caller", &self.caller());
      ds.field("caller_authid", &self.caller_authid());
      ds.field("caller_authrole", &self.caller_authrole());
      ds.field("forward_for", &self.forward_for());
      ds.finish()
  }
}
pub enum InterruptOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Interrupt<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Interrupt<'a> {
  type Inner = Interrupt<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Interrupt<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_MODE: flatbuffers::VOffsetT = 6;
  pub const VT_REASON: flatbuffers::VOffsetT = 8;
  pub const VT_FORWARD_FOR: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Interrupt { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args InterruptArgs<'args>
  ) -> flatbuffers::WIPOffset<Interrupt<'bldr>> {
    let mut builder = InterruptBuilder::new(_fbb);
    builder.add_request(args.request);
    if let Some(x) = args.forward_for { builder.add_forward_for(x); }
    if let Some(x) = args.reason { builder.add_reason(x); }
    builder.add_mode(args.mode);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Interrupt::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Interrupt) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn mode(&self) -> CancelMode {
    self._tab.get::<CancelMode>(Interrupt::VT_MODE, Some(CancelMode::ABORT)).unwrap()
  }
  #[inline]
  pub fn reason(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Interrupt::VT_REASON, None)
  }
  #[inline]
  pub fn forward_for(&self) -> Option<&'a [Principal]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Principal>>>(Interrupt::VT_FORWARD_FOR, None).map(|v| v.safe_slice())
  }
}

/*
impl flatbuffers::Verifiable for Interrupt<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<CancelMode>("mode", Self::VT_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reason", Self::VT_REASON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Principal>>>("forward_for", Self::VT_FORWARD_FOR, false)?
     .finish();
    Ok(())
  }
}
 */
pub struct InterruptArgs<'a> {
    pub request: u64,
    pub mode: CancelMode,
    pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
    pub forward_for: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Principal>>>,
}
impl<'a> Default for InterruptArgs<'a> {
  #[inline]
  fn default() -> Self {
    InterruptArgs {
      request: 0,
      mode: CancelMode::ABORT,
      reason: None,
      forward_for: None,
    }
  }
}

pub struct InterruptBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InterruptBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Interrupt::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_mode(&mut self, mode: CancelMode) {
    self.fbb_.push_slot::<CancelMode>(Interrupt::VT_MODE, mode, CancelMode::ABORT);
  }
  #[inline]
  pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Interrupt::VT_REASON, reason);
  }
  #[inline]
  pub fn add_forward_for(&mut self, forward_for: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Principal>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Interrupt::VT_FORWARD_FOR, forward_for);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InterruptBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InterruptBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Interrupt<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Interrupt<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Interrupt");
      ds.field("request", &self.request());
      ds.field("mode", &self.mode());
      ds.field("reason", &self.reason());
      ds.field("forward_for", &self.forward_for());
      ds.finish()
  }
}
pub enum YieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Yield<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Yield<'a> {
  type Inner = Yield<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Yield<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;
  pub const VT_ENC_ALGO: flatbuffers::VOffsetT = 8;
  pub const VT_ENC_SERIALIZER: flatbuffers::VOffsetT = 10;
  pub const VT_ENC_KEY: flatbuffers::VOffsetT = 12;
  pub const VT_PROGRESS: flatbuffers::VOffsetT = 14;
  pub const VT_CALLEE: flatbuffers::VOffsetT = 16;
  pub const VT_CALLEE_AUTHID: flatbuffers::VOffsetT = 18;
  pub const VT_CALLEE_AUTHROLE: flatbuffers::VOffsetT = 20;
  pub const VT_FORWARD_FOR: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Yield { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args YieldArgs<'args>
  ) -> flatbuffers::WIPOffset<Yield<'bldr>> {
    let mut builder = YieldBuilder::new(_fbb);
    builder.add_callee(args.callee);
    builder.add_request(args.request);
    if let Some(x) = args.forward_for { builder.add_forward_for(x); }
    if let Some(x) = args.callee_authrole { builder.add_callee_authrole(x); }
    if let Some(x) = args.callee_authid { builder.add_callee_authid(x); }
    if let Some(x) = args.enc_key { builder.add_enc_key(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    builder.add_progress(args.progress);
    builder.add_enc_serializer(args.enc_serializer);
    builder.add_enc_algo(args.enc_algo);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Yield::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Yield) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn payload(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Yield::VT_PAYLOAD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn enc_algo(&self) -> Payload {
    self._tab.get::<Payload>(Yield::VT_ENC_ALGO, Some(Payload::PLAIN)).unwrap()
  }
  #[inline]
  pub fn enc_serializer(&self) -> Serializer {
    self._tab.get::<Serializer>(Yield::VT_ENC_SERIALIZER, Some(Serializer::TRANSPORT)).unwrap()
  }
  #[inline]
  pub fn enc_key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Yield::VT_ENC_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn progress(&self) -> bool {
    self._tab.get::<bool>(Yield::VT_PROGRESS, Some(false)).unwrap()
  }
  #[inline]
  pub fn callee(&self) -> u64 {
    self._tab.get::<u64>(Yield::VT_CALLEE, Some(0)).unwrap()
  }
  #[inline]
  pub fn callee_authid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Yield::VT_CALLEE_AUTHID, None)
  }
  #[inline]
  pub fn callee_authrole(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Yield::VT_CALLEE_AUTHROLE, None)
  }
  #[inline]
  pub fn forward_for(&self) -> Option<&'a [Principal]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Principal>>>(Yield::VT_FORWARD_FOR, None).map(|v| v.safe_slice())
  }
}

/*
impl flatbuffers::Verifiable for Yield<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<Payload>("enc_algo", Self::VT_ENC_ALGO, false)?
     .visit_field::<Serializer>("enc_serializer", Self::VT_ENC_SERIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("enc_key", Self::VT_ENC_KEY, false)?
     .visit_field::<bool>("progress", Self::VT_PROGRESS, false)?
     .visit_field::<u64>("callee", Self::VT_CALLEE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callee_authid", Self::VT_CALLEE_AUTHID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("callee_authrole", Self::VT_CALLEE_AUTHROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Principal>>>("forward_for", Self::VT_FORWARD_FOR, false)?
     .finish();
    Ok(())
  }
   */
pub struct YieldArgs<'a> {
    pub request: u64,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub enc_algo: Payload,
    pub enc_serializer: Serializer,
    pub enc_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub progress: bool,
    pub callee: u64,
    pub callee_authid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub callee_authrole: Option<flatbuffers::WIPOffset<&'a str>>,
    pub forward_for: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Principal>>>,
}
impl<'a> Default for YieldArgs<'a> {
  #[inline]
  fn default() -> Self {
    YieldArgs {
      request: 0,
      payload: None,
      enc_algo: Payload::PLAIN,
      enc_serializer: Serializer::TRANSPORT,
      enc_key: None,
      progress: false,
      callee: 0,
      callee_authid: None,
      callee_authrole: None,
      forward_for: None,
    }
  }
}

pub struct YieldBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> YieldBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Yield::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Yield::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_enc_algo(&mut self, enc_algo: Payload) {
    self.fbb_.push_slot::<Payload>(Yield::VT_ENC_ALGO, enc_algo, Payload::PLAIN);
  }
  #[inline]
  pub fn add_enc_serializer(&mut self, enc_serializer: Serializer) {
    self.fbb_.push_slot::<Serializer>(Yield::VT_ENC_SERIALIZER, enc_serializer, Serializer::TRANSPORT);
  }
  #[inline]
  pub fn add_enc_key(&mut self, enc_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Yield::VT_ENC_KEY, enc_key);
  }
  #[inline]
  pub fn add_progress(&mut self, progress: bool) {
    self.fbb_.push_slot::<bool>(Yield::VT_PROGRESS, progress, false);
  }
  #[inline]
  pub fn add_callee(&mut self, callee: u64) {
    self.fbb_.push_slot::<u64>(Yield::VT_CALLEE, callee, 0);
  }
  #[inline]
  pub fn add_callee_authid(&mut self, callee_authid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Yield::VT_CALLEE_AUTHID, callee_authid);
  }
  #[inline]
  pub fn add_callee_authrole(&mut self, callee_authrole: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Yield::VT_CALLEE_AUTHROLE, callee_authrole);
  }
  #[inline]
  pub fn add_forward_for(&mut self, forward_for: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Principal>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Yield::VT_FORWARD_FOR, forward_for);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> YieldBuilder<'a, 'b> {
    let start = _fbb.start_table();
    YieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Yield<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Yield<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Yield");
      ds.field("request", &self.request());
      ds.field("payload", &self.payload());
      ds.field("enc_algo", &self.enc_algo());
      ds.field("enc_serializer", &self.enc_serializer());
      ds.field("enc_key", &self.enc_key());
      ds.field("progress", &self.progress());
      ds.field("callee", &self.callee());
      ds.field("callee_authid", &self.callee_authid());
      ds.field("callee_authrole", &self.callee_authrole());
      ds.field("forward_for", &self.forward_for());
      ds.finish()
  }
}
}  // pub mod proto
}  // pub mod wamp

