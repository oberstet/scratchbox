// automatically generated by the FlatBuffers compiler, do not modify



use crate::types_generated::*;
use crate::roles_generated::*;
use crate::rpc_generated::*;
use crate::session_generated::*;
use crate::auth_generated::*;
use crate::pubsub_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod wamp {

  use crate::types_generated::*;
  use crate::roles_generated::*;
  use crate::rpc_generated::*;
  use crate::session_generated::*;
  use crate::session_generated::wamp::proto::Hello;
  use crate::session_generated::wamp::proto::Welcome;
  use crate::session_generated::wamp::proto::Goodbye;
  use crate::session_generated::wamp::proto::Abort;
  use crate::session_generated::wamp::proto::Challenge;
  use crate::session_generated::wamp::proto::Authenticate;
  use crate::session_generated::wamp::proto::Error;
  use crate::auth_generated::*;
  use crate::pubsub_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod proto {

  use crate::types_generated::*;
  use crate::types_generated::wamp::proto::Principal;
  use crate::roles_generated::*;
  use crate::roles_generated::wamp::proto::ClientRoles;
  use crate::roles_generated::wamp::proto::RouterRoles;
  use crate::rpc_generated::*;
  use crate::rpc_generated::wamp::proto::Register;
  use crate::rpc_generated::wamp::proto::Registered;
  use crate::rpc_generated::wamp::proto::Unregister;
  use crate::rpc_generated::wamp::proto::Unregistered;
  use crate::rpc_generated::wamp::proto::Call;
  use crate::rpc_generated::wamp::proto::Cancel;
  use crate::rpc_generated::wamp::proto::Yield;
  use crate::rpc_generated::wamp::proto::Interrupt;
  use crate::rpc_generated::wamp::proto::Invocation;
  use crate::session_generated::*;
  use crate::session_generated::wamp::proto::Hello;
  use crate::session_generated::wamp::proto::Welcome;
  use crate::session_generated::wamp::proto::Goodbye;
  use crate::session_generated::wamp::proto::Abort;
  use crate::session_generated::wamp::proto::Challenge;
  use crate::session_generated::wamp::proto::Authenticate;
  use crate::session_generated::wamp::proto::Error;
  use crate::auth_generated::*;
  use crate::pubsub_generated::*;
  use crate::pubsub_generated::wamp::proto::Publish;
  use crate::pubsub_generated::wamp::proto::Published;
  use crate::pubsub_generated::wamp::proto::Subscribe;
  use crate::pubsub_generated::wamp::proto::Subscribed;
  use crate::pubsub_generated::wamp::proto::Unsubscribe;
  use crate::pubsub_generated::wamp::proto::Unsubscribed;
  use crate::pubsub_generated::wamp::proto::Event;
  use crate::pubsub_generated::wamp::proto::EventReceived;
  use crate::pubsub_generated::wamp::proto::SubscriberReceived;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANY_MESSAGE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANY_MESSAGE: u8 = 26;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANY_MESSAGE: [AnyMessage; 27] = [
  AnyMessage::NONE,
  AnyMessage::Hello,
  AnyMessage::Welcome,
  AnyMessage::Abort,
  AnyMessage::Challenge,
  AnyMessage::Authenticate,
  AnyMessage::Goodbye,
  AnyMessage::Error,
  AnyMessage::Publish,
  AnyMessage::Published,
  AnyMessage::SubscriberReceived,
  AnyMessage::Subscribe,
  AnyMessage::Subscribed,
  AnyMessage::Unsubscribe,
  AnyMessage::Unsubscribed,
  AnyMessage::Event,
  AnyMessage::EventReceived,
  AnyMessage::Call,
  AnyMessage::Cancel,
  AnyMessage::Result,
  AnyMessage::Register,
  AnyMessage::Registered,
  AnyMessage::Unregister,
  AnyMessage::Unregistered,
  AnyMessage::Invocation,
  AnyMessage::Interrupt,
  AnyMessage::Yield,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AnyMessage(pub u8);
#[allow(non_upper_case_globals)]
impl AnyMessage {
  pub const NONE: Self = Self(0);
  pub const Hello: Self = Self(1);
  pub const Welcome: Self = Self(2);
  pub const Abort: Self = Self(3);
  pub const Challenge: Self = Self(4);
  pub const Authenticate: Self = Self(5);
  pub const Goodbye: Self = Self(6);
  pub const Error: Self = Self(7);
  pub const Publish: Self = Self(8);
  pub const Published: Self = Self(9);
  pub const SubscriberReceived: Self = Self(10);
  pub const Subscribe: Self = Self(11);
  pub const Subscribed: Self = Self(12);
  pub const Unsubscribe: Self = Self(13);
  pub const Unsubscribed: Self = Self(14);
  pub const Event: Self = Self(15);
  pub const EventReceived: Self = Self(16);
  pub const Call: Self = Self(17);
  pub const Cancel: Self = Self(18);
  pub const Result: Self = Self(19);
  pub const Register: Self = Self(20);
  pub const Registered: Self = Self(21);
  pub const Unregister: Self = Self(22);
  pub const Unregistered: Self = Self(23);
  pub const Invocation: Self = Self(24);
  pub const Interrupt: Self = Self(25);
  pub const Yield: Self = Self(26);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 26;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Hello,
    Self::Welcome,
    Self::Abort,
    Self::Challenge,
    Self::Authenticate,
    Self::Goodbye,
    Self::Error,
    Self::Publish,
    Self::Published,
    Self::SubscriberReceived,
    Self::Subscribe,
    Self::Subscribed,
    Self::Unsubscribe,
    Self::Unsubscribed,
    Self::Event,
    Self::EventReceived,
    Self::Call,
    Self::Cancel,
    Self::Result,
    Self::Register,
    Self::Registered,
    Self::Unregister,
    Self::Unregistered,
    Self::Invocation,
    Self::Interrupt,
    Self::Yield,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Hello => Some("Hello"),
      Self::Welcome => Some("Welcome"),
      Self::Abort => Some("Abort"),
      Self::Challenge => Some("Challenge"),
      Self::Authenticate => Some("Authenticate"),
      Self::Goodbye => Some("Goodbye"),
      Self::Error => Some("Error"),
      Self::Publish => Some("Publish"),
      Self::Published => Some("Published"),
      Self::SubscriberReceived => Some("SubscriberReceived"),
      Self::Subscribe => Some("Subscribe"),
      Self::Subscribed => Some("Subscribed"),
      Self::Unsubscribe => Some("Unsubscribe"),
      Self::Unsubscribed => Some("Unsubscribed"),
      Self::Event => Some("Event"),
      Self::EventReceived => Some("EventReceived"),
      Self::Call => Some("Call"),
      Self::Cancel => Some("Cancel"),
      Self::Result => Some("Result"),
      Self::Register => Some("Register"),
      Self::Registered => Some("Registered"),
      Self::Unregister => Some("Unregister"),
      Self::Unregistered => Some("Unregistered"),
      Self::Invocation => Some("Invocation"),
      Self::Interrupt => Some("Interrupt"),
      Self::Yield => Some("Yield"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AnyMessage {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AnyMessage {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for AnyMessage {
    type Output = AnyMessage;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for AnyMessage {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AnyMessage {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AnyMessage {}
pub struct AnyMessageUnionTableOffset {}

pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
  type Inner = Message<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Message<'a> {
  pub const VT_MSG_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_MSG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Message { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MessageArgs
  ) -> flatbuffers::WIPOffset<Message<'bldr>> {
    let mut builder = MessageBuilder::new(_fbb);
    if let Some(x) = args.msg { builder.add_msg(x); }
    builder.add_msg_type(args.msg_type);
    builder.finish()
  }


  #[inline]
  pub fn msg_type(&self) -> AnyMessage {
    self._tab.get::<AnyMessage>(Message::VT_MSG_TYPE, Some(AnyMessage::NONE)).unwrap()
  }
  #[inline]
  pub fn msg(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_MSG, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_hello(&self) -> Option<Hello<'a>> {
    if self.msg_type() == AnyMessage::Hello {
      let u = self.msg();
      Some(Hello::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_welcome(&self) -> Option<Welcome<'a>> {
    if self.msg_type() == AnyMessage::Welcome {
      let u = self.msg();
      Some(Welcome::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_abort(&self) -> Option<Abort<'a>> {
    if self.msg_type() == AnyMessage::Abort {
      let u = self.msg();
      Some(Abort::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_challenge(&self) -> Option<Challenge<'a>> {
    if self.msg_type() == AnyMessage::Challenge {
      let u = self.msg();
      Some(Challenge::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_authenticate(&self) -> Option<Authenticate<'a>> {
    if self.msg_type() == AnyMessage::Authenticate {
      let u = self.msg();
      Some(Authenticate::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_goodbye(&self) -> Option<Goodbye<'a>> {
    if self.msg_type() == AnyMessage::Goodbye {
      let u = self.msg();
      Some(Goodbye::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_error(&self) -> Option<Error<'a>> {
    if self.msg_type() == AnyMessage::Error {
      let u = self.msg();
      Some(Error::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_publish(&self) -> Option<Publish<'a>> {
    if self.msg_type() == AnyMessage::Publish {
      let u = self.msg();
      Some(Publish::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_published(&self) -> Option<Published<'a>> {
    if self.msg_type() == AnyMessage::Published {
      let u = self.msg();
      Some(Published::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_subscriber_received(&self) -> Option<SubscriberReceived<'a>> {
    if self.msg_type() == AnyMessage::SubscriberReceived {
      let u = self.msg();
      Some(SubscriberReceived::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_subscribe(&self) -> Option<Subscribe<'a>> {
    if self.msg_type() == AnyMessage::Subscribe {
      let u = self.msg();
      Some(Subscribe::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_subscribed(&self) -> Option<Subscribed<'a>> {
    if self.msg_type() == AnyMessage::Subscribed {
      let u = self.msg();
      Some(Subscribed::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_unsubscribe(&self) -> Option<Unsubscribe<'a>> {
    if self.msg_type() == AnyMessage::Unsubscribe {
      let u = self.msg();
      Some(Unsubscribe::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_unsubscribed(&self) -> Option<Unsubscribed<'a>> {
    if self.msg_type() == AnyMessage::Unsubscribed {
      let u = self.msg();
      Some(Unsubscribed::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_event(&self) -> Option<Event<'a>> {
    if self.msg_type() == AnyMessage::Event {
      let u = self.msg();
      Some(Event::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_event_received(&self) -> Option<EventReceived<'a>> {
    if self.msg_type() == AnyMessage::EventReceived {
      let u = self.msg();
      Some(EventReceived::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_call(&self) -> Option<Call<'a>> {
    if self.msg_type() == AnyMessage::Call {
      let u = self.msg();
      Some(Call::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_cancel(&self) -> Option<Cancel<'a>> {
    if self.msg_type() == AnyMessage::Cancel {
      let u = self.msg();
      Some(Cancel::init_from_table(u))
    } else {
      None
    }
  }

  /* FIXME: expected 0 lifetime arguments
  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_result(&self) -> Option<Result<'a>> {
    if self.msg_type() == AnyMessage::Result {
      let u = self.msg();
      Some(Result::init_from_table(u))
    } else {
      None
    }
  }
   */

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_register(&self) -> Option<Register<'a>> {
    if self.msg_type() == AnyMessage::Register {
      let u = self.msg();
      Some(Register::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_registered(&self) -> Option<Registered<'a>> {
    if self.msg_type() == AnyMessage::Registered {
      let u = self.msg();
      Some(Registered::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_unregister(&self) -> Option<Unregister<'a>> {
    if self.msg_type() == AnyMessage::Unregister {
      let u = self.msg();
      Some(Unregister::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_unregistered(&self) -> Option<Unregistered<'a>> {
    if self.msg_type() == AnyMessage::Unregistered {
      let u = self.msg();
      Some(Unregistered::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_invocation(&self) -> Option<Invocation<'a>> {
    if self.msg_type() == AnyMessage::Invocation {
      let u = self.msg();
      Some(Invocation::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_interrupt(&self) -> Option<Interrupt<'a>> {
    if self.msg_type() == AnyMessage::Interrupt {
      let u = self.msg();
      Some(Interrupt::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn msg_as_yield(&self) -> Option<Yield<'a>> {
    if self.msg_type() == AnyMessage::Yield {
      let u = self.msg();
      Some(Yield::init_from_table(u))
    } else {
      None
    }
  }

}

/*
impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<AnyMessage, _>("msg_type", Self::VT_MSG_TYPE, "msg", Self::VT_MSG, true, |key, v, pos| {
        match key {
          AnyMessage::Hello => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Hello>>("AnyMessage::Hello", pos),
          AnyMessage::Welcome => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Welcome>>("AnyMessage::Welcome", pos),
          AnyMessage::Abort => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Abort>>("AnyMessage::Abort", pos),
          AnyMessage::Challenge => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Challenge>>("AnyMessage::Challenge", pos),
          AnyMessage::Authenticate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Authenticate>>("AnyMessage::Authenticate", pos),
          AnyMessage::Goodbye => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Goodbye>>("AnyMessage::Goodbye", pos),
          AnyMessage::Error => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Error>>("AnyMessage::Error", pos),
          AnyMessage::Publish => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Publish>>("AnyMessage::Publish", pos),
          AnyMessage::Published => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Published>>("AnyMessage::Published", pos),
          AnyMessage::SubscriberReceived => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SubscriberReceived>>("AnyMessage::SubscriberReceived", pos),
          AnyMessage::Subscribe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Subscribe>>("AnyMessage::Subscribe", pos),
          AnyMessage::Subscribed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Subscribed>>("AnyMessage::Subscribed", pos),
          AnyMessage::Unsubscribe => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Unsubscribe>>("AnyMessage::Unsubscribe", pos),
          AnyMessage::Unsubscribed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Unsubscribed>>("AnyMessage::Unsubscribed", pos),
          AnyMessage::Event => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Event>>("AnyMessage::Event", pos),
          AnyMessage::EventReceived => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventReceived>>("AnyMessage::EventReceived", pos),
          AnyMessage::Call => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Call>>("AnyMessage::Call", pos),
          AnyMessage::Cancel => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Cancel>>("AnyMessage::Cancel", pos),
          AnyMessage::Result => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Result>>("AnyMessage::Result", pos),
          AnyMessage::Register => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Register>>("AnyMessage::Register", pos),
          AnyMessage::Registered => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Registered>>("AnyMessage::Registered", pos),
          AnyMessage::Unregister => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Unregister>>("AnyMessage::Unregister", pos),
          AnyMessage::Unregistered => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Unregistered>>("AnyMessage::Unregistered", pos),
          AnyMessage::Invocation => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Invocation>>("AnyMessage::Invocation", pos),
          AnyMessage::Interrupt => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Interrupt>>("AnyMessage::Interrupt", pos),
          AnyMessage::Yield => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Yield>>("AnyMessage::Yield", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
 */
pub struct MessageArgs {
    pub msg_type: AnyMessage,
    pub msg: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MessageArgs {
  #[inline]
  fn default() -> Self {
    MessageArgs {
      msg_type: AnyMessage::NONE,
      msg: None, // required field
    }
  }
}

pub struct MessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_msg_type(&mut self, msg_type: AnyMessage) {
    self.fbb_.push_slot::<AnyMessage>(Message::VT_MSG_TYPE, msg_type, AnyMessage::NONE);
  }
  #[inline]
  pub fn add_msg(&mut self, msg: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_MSG, msg);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Message::VT_MSG,"msg");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("msg_type", &self.msg_type());
      match self.msg_type() {
        AnyMessage::Hello => {
          if let Some(x) = self.msg_as_hello() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Welcome => {
          if let Some(x) = self.msg_as_welcome() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Abort => {
          if let Some(x) = self.msg_as_abort() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Challenge => {
          if let Some(x) = self.msg_as_challenge() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Authenticate => {
          if let Some(x) = self.msg_as_authenticate() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Goodbye => {
          if let Some(x) = self.msg_as_goodbye() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Error => {
          if let Some(x) = self.msg_as_error() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Publish => {
          if let Some(x) = self.msg_as_publish() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Published => {
          if let Some(x) = self.msg_as_published() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::SubscriberReceived => {
          if let Some(x) = self.msg_as_subscriber_received() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Subscribe => {
          if let Some(x) = self.msg_as_subscribe() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Subscribed => {
          if let Some(x) = self.msg_as_subscribed() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Unsubscribe => {
          if let Some(x) = self.msg_as_unsubscribe() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Unsubscribed => {
          if let Some(x) = self.msg_as_unsubscribed() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Event => {
          if let Some(x) = self.msg_as_event() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::EventReceived => {
          if let Some(x) = self.msg_as_event_received() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Call => {
          if let Some(x) = self.msg_as_call() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Cancel => {
          if let Some(x) = self.msg_as_cancel() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        /*
        AnyMessage::Result => {
          if let Some(x) = self.msg_as_result() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
         */
        AnyMessage::Register => {
          if let Some(x) = self.msg_as_register() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Registered => {
          if let Some(x) = self.msg_as_registered() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Unregister => {
          if let Some(x) = self.msg_as_unregister() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Unregistered => {
          if let Some(x) = self.msg_as_unregistered() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Invocation => {
          if let Some(x) = self.msg_as_invocation() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Interrupt => {
          if let Some(x) = self.msg_as_interrupt() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AnyMessage::Yield => {
          if let Some(x) = self.msg_as_yield() {
            ds.field("msg", &x)
          } else {
            ds.field("msg", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("msg", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  unsafe { flatbuffers::root_unchecked::<Message<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Message<'a>>(buf) }
}

/*
#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
 */
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::root_unchecked::<Message>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
}
#[inline]
pub fn finish_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod proto
}  // pub mod wamp

