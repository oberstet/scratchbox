// automatically generated by the FlatBuffers compiler, do not modify



use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod wamp {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum MapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Map<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Map<'a> {
  type Inner = Map<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Map<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Map { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MapArgs<'args>
  ) -> flatbuffers::WIPOffset<Map<'bldr>> {
    let mut builder = MapBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Map::VT_KEY, None).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Map) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Map::VT_VALUE, None)
  }
}

impl flatbuffers::Verifiable for Map<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct MapArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MapArgs<'a> {
  #[inline]
  fn default() -> Self {
    MapArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct MapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MapBuilder<'a, 'b> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Map::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Map::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Map<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Map::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Map<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Map");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum VoidOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Void<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Void<'a> {
  type Inner = Void<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Void<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Void { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args VoidArgs
  ) -> flatbuffers::WIPOffset<Void<'bldr>> {
    let mut builder = VoidBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for Void<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct VoidArgs {
}
impl<'a> Default for VoidArgs {
  #[inline]
  fn default() -> Self {
    VoidArgs {
    }
  }
}

pub struct VoidBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VoidBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VoidBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VoidBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Void<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Void<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Void");
      ds.finish()
  }
}
#[allow(unused_imports, dead_code)]
pub mod proto {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_TYPE: u16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_TYPE: u16 = 70;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_TYPE: [MessageType; 27] = [
  MessageType::NULL,
  MessageType::HELLO,
  MessageType::WELCOME,
  MessageType::ABORT,
  MessageType::CHALLENGE,
  MessageType::AUTHENTICATE,
  MessageType::GOODBYE,
  MessageType::ERROR,
  MessageType::PUBLISH,
  MessageType::PUBLISHED,
  MessageType::SUBSCRIBER_RECEIVED,
  MessageType::SUBSCRIBE,
  MessageType::SUBSCRIBED,
  MessageType::UNSUBSCRIBE,
  MessageType::UNSUBSCRIBED,
  MessageType::EVENT,
  MessageType::EVENT_RECEIVED,
  MessageType::CALL,
  MessageType::CANCEL,
  MessageType::RESULT,
  MessageType::REGISTER,
  MessageType::REGISTERED,
  MessageType::UNREGISTER,
  MessageType::UNREGISTERED,
  MessageType::INVOCATION,
  MessageType::INTERRUPT,
  MessageType::YIELD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessageType(pub u16);
#[allow(non_upper_case_globals)]
impl MessageType {
  pub const NULL: Self = Self(0);
  pub const HELLO: Self = Self(1);
  pub const WELCOME: Self = Self(2);
  pub const ABORT: Self = Self(3);
  pub const CHALLENGE: Self = Self(4);
  pub const AUTHENTICATE: Self = Self(5);
  pub const GOODBYE: Self = Self(6);
  pub const ERROR: Self = Self(8);
  pub const PUBLISH: Self = Self(16);
  pub const PUBLISHED: Self = Self(17);
  pub const SUBSCRIBER_RECEIVED: Self = Self(18);
  pub const SUBSCRIBE: Self = Self(32);
  pub const SUBSCRIBED: Self = Self(33);
  pub const UNSUBSCRIBE: Self = Self(34);
  pub const UNSUBSCRIBED: Self = Self(35);
  pub const EVENT: Self = Self(36);
  pub const EVENT_RECEIVED: Self = Self(37);
  pub const CALL: Self = Self(48);
  pub const CANCEL: Self = Self(49);
  pub const RESULT: Self = Self(50);
  pub const REGISTER: Self = Self(64);
  pub const REGISTERED: Self = Self(65);
  pub const UNREGISTER: Self = Self(66);
  pub const UNREGISTERED: Self = Self(67);
  pub const INVOCATION: Self = Self(68);
  pub const INTERRUPT: Self = Self(69);
  pub const YIELD: Self = Self(70);

  pub const ENUM_MIN: u16 = 0;
  pub const ENUM_MAX: u16 = 70;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NULL,
    Self::HELLO,
    Self::WELCOME,
    Self::ABORT,
    Self::CHALLENGE,
    Self::AUTHENTICATE,
    Self::GOODBYE,
    Self::ERROR,
    Self::PUBLISH,
    Self::PUBLISHED,
    Self::SUBSCRIBER_RECEIVED,
    Self::SUBSCRIBE,
    Self::SUBSCRIBED,
    Self::UNSUBSCRIBE,
    Self::UNSUBSCRIBED,
    Self::EVENT,
    Self::EVENT_RECEIVED,
    Self::CALL,
    Self::CANCEL,
    Self::RESULT,
    Self::REGISTER,
    Self::REGISTERED,
    Self::UNREGISTER,
    Self::UNREGISTERED,
    Self::INVOCATION,
    Self::INTERRUPT,
    Self::YIELD,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NULL => Some("NULL"),
      Self::HELLO => Some("HELLO"),
      Self::WELCOME => Some("WELCOME"),
      Self::ABORT => Some("ABORT"),
      Self::CHALLENGE => Some("CHALLENGE"),
      Self::AUTHENTICATE => Some("AUTHENTICATE"),
      Self::GOODBYE => Some("GOODBYE"),
      Self::ERROR => Some("ERROR"),
      Self::PUBLISH => Some("PUBLISH"),
      Self::PUBLISHED => Some("PUBLISHED"),
      Self::SUBSCRIBER_RECEIVED => Some("SUBSCRIBER_RECEIVED"),
      Self::SUBSCRIBE => Some("SUBSCRIBE"),
      Self::SUBSCRIBED => Some("SUBSCRIBED"),
      Self::UNSUBSCRIBE => Some("UNSUBSCRIBE"),
      Self::UNSUBSCRIBED => Some("UNSUBSCRIBED"),
      Self::EVENT => Some("EVENT"),
      Self::EVENT_RECEIVED => Some("EVENT_RECEIVED"),
      Self::CALL => Some("CALL"),
      Self::CANCEL => Some("CANCEL"),
      Self::RESULT => Some("RESULT"),
      Self::REGISTER => Some("REGISTER"),
      Self::REGISTERED => Some("REGISTERED"),
      Self::UNREGISTER => Some("UNREGISTER"),
      Self::UNREGISTERED => Some("UNREGISTERED"),
      Self::INVOCATION => Some("INVOCATION"),
      Self::INTERRUPT => Some("INTERRUPT"),
      Self::YIELD => Some("YIELD"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessageType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u16>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for MessageType {
    type Output = MessageType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u16>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for MessageType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u16::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u16::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessageType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PAYLOAD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PAYLOAD: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PAYLOAD: [Payload; 3] = [
  Payload::PLAIN,
  Payload::CRYPTOBOX,
  Payload::OPAQUE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Payload(pub u8);
#[allow(non_upper_case_globals)]
impl Payload {
  pub const PLAIN: Self = Self(0);
  pub const CRYPTOBOX: Self = Self(1);
  pub const OPAQUE: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PLAIN,
    Self::CRYPTOBOX,
    Self::OPAQUE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PLAIN => Some("PLAIN"),
      Self::CRYPTOBOX => Some("CRYPTOBOX"),
      Self::OPAQUE => Some("OPAQUE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Payload {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Payload {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Payload {
    type Output = Payload;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Payload {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Payload {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Payload {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SERIALIZER: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SERIALIZER: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SERIALIZER: [Serializer; 7] = [
  Serializer::TRANSPORT,
  Serializer::JSON,
  Serializer::MSGPACK,
  Serializer::CBOR,
  Serializer::UBJSON,
  Serializer::OPAQUE,
  Serializer::FLATBUFFERS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Serializer(pub u8);
#[allow(non_upper_case_globals)]
impl Serializer {
  pub const TRANSPORT: Self = Self(0);
  pub const JSON: Self = Self(1);
  pub const MSGPACK: Self = Self(2);
  pub const CBOR: Self = Self(3);
  pub const UBJSON: Self = Self(4);
  pub const OPAQUE: Self = Self(5);
  pub const FLATBUFFERS: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TRANSPORT,
    Self::JSON,
    Self::MSGPACK,
    Self::CBOR,
    Self::UBJSON,
    Self::OPAQUE,
    Self::FLATBUFFERS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TRANSPORT => Some("TRANSPORT"),
      Self::JSON => Some("JSON"),
      Self::MSGPACK => Some("MSGPACK"),
      Self::CBOR => Some("CBOR"),
      Self::UBJSON => Some("UBJSON"),
      Self::OPAQUE => Some("OPAQUE"),
      Self::FLATBUFFERS => Some("FLATBUFFERS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Serializer {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Serializer {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Serializer {
    type Output = Serializer;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Serializer {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Serializer {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Serializer {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MATCH: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MATCH: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MATCH: [Match; 3] = [
  Match::EXACT,
  Match::PREFIX,
  Match::WILDCARD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Match(pub u8);
#[allow(non_upper_case_globals)]
impl Match {
  pub const EXACT: Self = Self(0);
  pub const PREFIX: Self = Self(1);
  pub const WILDCARD: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EXACT,
    Self::PREFIX,
    Self::WILDCARD,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::EXACT => Some("EXACT"),
      Self::PREFIX => Some("PREFIX"),
      Self::WILDCARD => Some("WILDCARD"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Match {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Match {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Match {
    type Output = Match;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Match {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Match {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Match {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_INVOCATION_POLICY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_INVOCATION_POLICY: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_INVOCATION_POLICY: [InvocationPolicy; 5] = [
  InvocationPolicy::SINGLE,
  InvocationPolicy::FIRST,
  InvocationPolicy::LAST,
  InvocationPolicy::ROUNDROBIN,
  InvocationPolicy::RANDOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct InvocationPolicy(pub u8);
#[allow(non_upper_case_globals)]
impl InvocationPolicy {
  pub const SINGLE: Self = Self(0);
  pub const FIRST: Self = Self(1);
  pub const LAST: Self = Self(2);
  pub const ROUNDROBIN: Self = Self(3);
  pub const RANDOM: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SINGLE,
    Self::FIRST,
    Self::LAST,
    Self::ROUNDROBIN,
    Self::RANDOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SINGLE => Some("SINGLE"),
      Self::FIRST => Some("FIRST"),
      Self::LAST => Some("LAST"),
      Self::ROUNDROBIN => Some("ROUNDROBIN"),
      Self::RANDOM => Some("RANDOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for InvocationPolicy {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for InvocationPolicy {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for InvocationPolicy {
    type Output = InvocationPolicy;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for InvocationPolicy {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for InvocationPolicy {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for InvocationPolicy {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CANCEL_MODE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CANCEL_MODE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CANCEL_MODE: [CancelMode; 3] = [
  CancelMode::SKIP,
  CancelMode::ABORT,
  CancelMode::KILL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CancelMode(pub u8);
#[allow(non_upper_case_globals)]
impl CancelMode {
  pub const SKIP: Self = Self(0);
  pub const ABORT: Self = Self(1);
  pub const KILL: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SKIP,
    Self::ABORT,
    Self::KILL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SKIP => Some("SKIP"),
      Self::ABORT => Some("ABORT"),
      Self::KILL => Some("KILL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CancelMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CancelMode {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for CancelMode {
    type Output = CancelMode;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for CancelMode {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CancelMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CancelMode {}
// struct Principal, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Principal(pub [u8; 8]);
impl Default for Principal {
  fn default() -> Self {
    Self([0; 8])
  }
}
impl core::fmt::Debug for Principal {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Principal")
      .field("session", &self.session())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Principal {}
impl flatbuffers::SafeSliceAccess for Principal {}
impl<'a> flatbuffers::Follow<'a> for Principal {
  type Inner = &'a Principal;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Principal>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Principal {
  type Inner = &'a Principal;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Principal>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Principal {
    type Output = Principal;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::core::slice::from_raw_parts(self as *const Principal as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

/* FIXME: note: conflicting implementation in crate `flatbuffers`
impl<'b> flatbuffers::Push for &'b Principal {
    type Output = Principal;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::core::slice::from_raw_parts(*self as *const Principal as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
 */

impl<'a> flatbuffers::Verifiable for Principal {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Principal {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    session: u64,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_session(session);
    s
  }

  pub fn session(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<u64>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<u64>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_session(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const u64 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<u64>(),
      );
    }
  }

}

}  // pub mod proto
}  // pub mod wamp

