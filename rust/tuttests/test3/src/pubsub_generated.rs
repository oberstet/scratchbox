// automatically generated by the FlatBuffers compiler, do not modify



use crate::types_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod wamp {

  use crate::types_generated::*;
  use crate::types_generated::wamp::proto::Match;
  use crate::types_generated::wamp::proto::Serializer;
  use crate::types_generated::wamp::proto::Payload;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod proto {

  use crate::types_generated::*;
  use crate::types_generated::wamp::proto::Match;
  use crate::types_generated::wamp::proto::Serializer;
  use crate::types_generated::wamp::proto::Payload;
  use crate::types_generated::wamp::proto::Principal;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum SubscribeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Subscribe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Subscribe<'a> {
  type Inner = Subscribe<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Subscribe<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_TOPIC: flatbuffers::VOffsetT = 6;
  pub const VT_MATCH_: flatbuffers::VOffsetT = 8;
  pub const VT_GET_RETAINED: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Subscribe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubscribeArgs<'args>
  ) -> flatbuffers::WIPOffset<Subscribe<'bldr>> {
    let mut builder = SubscribeBuilder::new(_fbb);
    builder.add_request(args.request);
    if let Some(x) = args.topic { builder.add_topic(x); }
    builder.add_get_retained(args.get_retained);
    builder.add_match_(args.match_);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Subscribe::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Subscribe) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn topic(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Subscribe::VT_TOPIC, None).unwrap()
  }
  #[inline]
  pub fn match_(&self) -> Match {
    self._tab.get::<Match>(Subscribe::VT_MATCH_, Some(Match::EXACT)).unwrap()
  }
  #[inline]
  pub fn get_retained(&self) -> bool {
    self._tab.get::<bool>(Subscribe::VT_GET_RETAINED, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for Subscribe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("topic", Self::VT_TOPIC, true)?
     .visit_field::<Match>("match_", Self::VT_MATCH_, false)?
     .visit_field::<bool>("get_retained", Self::VT_GET_RETAINED, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscribeArgs<'a> {
    pub request: u64,
    pub topic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub match_: Match,
    pub get_retained: bool,
}
impl<'a> Default for SubscribeArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscribeArgs {
      request: 0,
      topic: None, // required field
      match_: Match::EXACT,
      get_retained: false,
    }
  }
}

pub struct SubscribeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubscribeBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Subscribe::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_topic(&mut self, topic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Subscribe::VT_TOPIC, topic);
  }
  #[inline]
  pub fn add_match_(&mut self, match_: Match) {
    self.fbb_.push_slot::<Match>(Subscribe::VT_MATCH_, match_, Match::EXACT);
  }
  #[inline]
  pub fn add_get_retained(&mut self, get_retained: bool) {
    self.fbb_.push_slot::<bool>(Subscribe::VT_GET_RETAINED, get_retained, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubscribeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubscribeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Subscribe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Subscribe::VT_TOPIC,"topic");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Subscribe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Subscribe");
      ds.field("request", &self.request());
      ds.field("topic", &self.topic());
      ds.field("match_", &self.match_());
      ds.field("get_retained", &self.get_retained());
      ds.finish()
  }
}
pub enum SubscribedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Subscribed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Subscribed<'a> {
  type Inner = Subscribed<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Subscribed<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_SUBSCRIPTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Subscribed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubscribedArgs
  ) -> flatbuffers::WIPOffset<Subscribed<'bldr>> {
    let mut builder = SubscribedBuilder::new(_fbb);
    builder.add_subscription(args.subscription);
    builder.add_request(args.request);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Subscribed::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Subscribed) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn subscription(&self) -> u64 {
    self._tab.get::<u64>(Subscribed::VT_SUBSCRIPTION, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Subscribed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<u64>("subscription", Self::VT_SUBSCRIPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscribedArgs {
    pub request: u64,
    pub subscription: u64,
}
impl<'a> Default for SubscribedArgs {
  #[inline]
  fn default() -> Self {
    SubscribedArgs {
      request: 0,
      subscription: 0,
    }
  }
}

pub struct SubscribedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubscribedBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Subscribed::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_subscription(&mut self, subscription: u64) {
    self.fbb_.push_slot::<u64>(Subscribed::VT_SUBSCRIPTION, subscription, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubscribedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubscribedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Subscribed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Subscribed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Subscribed");
      ds.field("request", &self.request());
      ds.field("subscription", &self.subscription());
      ds.finish()
  }
}
pub enum UnsubscribeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Unsubscribe<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Unsubscribe<'a> {
  type Inner = Unsubscribe<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Unsubscribe<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_SUBSCRIPTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Unsubscribe { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnsubscribeArgs
  ) -> flatbuffers::WIPOffset<Unsubscribe<'bldr>> {
    let mut builder = UnsubscribeBuilder::new(_fbb);
    builder.add_subscription(args.subscription);
    builder.add_request(args.request);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Unsubscribe::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Unsubscribe) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn subscription(&self) -> u64 {
    self._tab.get::<u64>(Unsubscribe::VT_SUBSCRIPTION, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Unsubscribe<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<u64>("subscription", Self::VT_SUBSCRIPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct UnsubscribeArgs {
    pub request: u64,
    pub subscription: u64,
}
impl<'a> Default for UnsubscribeArgs {
  #[inline]
  fn default() -> Self {
    UnsubscribeArgs {
      request: 0,
      subscription: 0,
    }
  }
}

pub struct UnsubscribeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnsubscribeBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Unsubscribe::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_subscription(&mut self, subscription: u64) {
    self.fbb_.push_slot::<u64>(Unsubscribe::VT_SUBSCRIPTION, subscription, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnsubscribeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnsubscribeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Unsubscribe<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Unsubscribe<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Unsubscribe");
      ds.field("request", &self.request());
      ds.field("subscription", &self.subscription());
      ds.finish()
  }
}
pub enum UnsubscribedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Unsubscribed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Unsubscribed<'a> {
  type Inner = Unsubscribed<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Unsubscribed<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_SUBSCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_REASON: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Unsubscribed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnsubscribedArgs<'args>
  ) -> flatbuffers::WIPOffset<Unsubscribed<'bldr>> {
    let mut builder = UnsubscribedBuilder::new(_fbb);
    builder.add_subscription(args.subscription);
    builder.add_request(args.request);
    if let Some(x) = args.reason { builder.add_reason(x); }
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Unsubscribed::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Unsubscribed) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn subscription(&self) -> u64 {
    self._tab.get::<u64>(Unsubscribed::VT_SUBSCRIPTION, Some(0)).unwrap()
  }
  #[inline]
  pub fn reason(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Unsubscribed::VT_REASON, None)
  }
}

impl flatbuffers::Verifiable for Unsubscribed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<u64>("subscription", Self::VT_SUBSCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("reason", Self::VT_REASON, false)?
     .finish();
    Ok(())
  }
}
pub struct UnsubscribedArgs<'a> {
    pub request: u64,
    pub subscription: u64,
    pub reason: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for UnsubscribedArgs<'a> {
  #[inline]
  fn default() -> Self {
    UnsubscribedArgs {
      request: 0,
      subscription: 0,
      reason: None,
    }
  }
}

pub struct UnsubscribedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnsubscribedBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Unsubscribed::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_subscription(&mut self, subscription: u64) {
    self.fbb_.push_slot::<u64>(Unsubscribed::VT_SUBSCRIPTION, subscription, 0);
  }
  #[inline]
  pub fn add_reason(&mut self, reason: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Unsubscribed::VT_REASON, reason);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnsubscribedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnsubscribedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Unsubscribed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Unsubscribed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Unsubscribed");
      ds.field("request", &self.request());
      ds.field("subscription", &self.subscription());
      ds.field("reason", &self.reason());
      ds.finish()
  }
}
pub enum PublishOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Publish<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Publish<'a> {
  type Inner = Publish<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Publish<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_TOPIC: flatbuffers::VOffsetT = 6;
  pub const VT_ARGS: flatbuffers::VOffsetT = 8;
  pub const VT_KWARGS: flatbuffers::VOffsetT = 10;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 12;
  pub const VT_ENC_ALGO: flatbuffers::VOffsetT = 14;
  pub const VT_ENC_SERIALIZER: flatbuffers::VOffsetT = 16;
  pub const VT_ENC_KEY: flatbuffers::VOffsetT = 18;
  pub const VT_ACKNOWLEDGE: flatbuffers::VOffsetT = 20;
  pub const VT_EXCLUDE_ME: flatbuffers::VOffsetT = 22;
  pub const VT_EXCLUDE: flatbuffers::VOffsetT = 24;
  pub const VT_EXCLUDE_AUTHID: flatbuffers::VOffsetT = 26;
  pub const VT_EXCLUDE_AUTHROLE: flatbuffers::VOffsetT = 28;
  pub const VT_ELIGIBLE: flatbuffers::VOffsetT = 30;
  pub const VT_ELIGIBLE_AUTHID: flatbuffers::VOffsetT = 32;
  pub const VT_ELIGIBLE_AUTHROLE: flatbuffers::VOffsetT = 34;
  pub const VT_RETAIN: flatbuffers::VOffsetT = 36;
  pub const VT_TRANSACTION_HASH: flatbuffers::VOffsetT = 38;
  pub const VT_FORWARD_FOR: flatbuffers::VOffsetT = 40;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Publish { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PublishArgs<'args>
  ) -> flatbuffers::WIPOffset<Publish<'bldr>> {
    let mut builder = PublishBuilder::new(_fbb);
    builder.add_request(args.request);
    if let Some(x) = args.forward_for { builder.add_forward_for(x); }
    if let Some(x) = args.transaction_hash { builder.add_transaction_hash(x); }
    if let Some(x) = args.eligible_authrole { builder.add_eligible_authrole(x); }
    if let Some(x) = args.eligible_authid { builder.add_eligible_authid(x); }
    if let Some(x) = args.eligible { builder.add_eligible(x); }
    if let Some(x) = args.exclude_authrole { builder.add_exclude_authrole(x); }
    if let Some(x) = args.exclude_authid { builder.add_exclude_authid(x); }
    if let Some(x) = args.exclude { builder.add_exclude(x); }
    if let Some(x) = args.enc_key { builder.add_enc_key(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.kwargs { builder.add_kwargs(x); }
    if let Some(x) = args.args { builder.add_args(x); }
    if let Some(x) = args.topic { builder.add_topic(x); }
    builder.add_retain(args.retain);
    builder.add_exclude_me(args.exclude_me);
    builder.add_acknowledge(args.acknowledge);
    builder.add_enc_serializer(args.enc_serializer);
    builder.add_enc_algo(args.enc_algo);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Publish::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Publish) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn topic(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Publish::VT_TOPIC, None).unwrap()
  }
  /// Positional values for application-defined event payload.
  #[inline]
  pub fn args(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Publish::VT_ARGS, None).map(|v| v.safe_slice())
  }
  /// Keyword values for application-defined event payload.
  #[inline]
  pub fn kwargs(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Publish::VT_KWARGS, None).map(|v| v.safe_slice())
  }
  /// Alternative, transparent payload. If given, ``args`` and ``kwargs`` must be left unset.
  #[inline]
  pub fn payload(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Publish::VT_PAYLOAD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn enc_algo(&self) -> Payload {
    self._tab.get::<Payload>(Publish::VT_ENC_ALGO, Some(Payload::PLAIN)).unwrap()
  }
  #[inline]
  pub fn enc_serializer(&self) -> Serializer {
    self._tab.get::<Serializer>(Publish::VT_ENC_SERIALIZER, Some(Serializer::TRANSPORT)).unwrap()
  }
  #[inline]
  pub fn enc_key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Publish::VT_ENC_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn acknowledge(&self) -> bool {
    self._tab.get::<bool>(Publish::VT_ACKNOWLEDGE, Some(false)).unwrap()
  }
  #[inline]
  pub fn exclude_me(&self) -> bool {
    self._tab.get::<bool>(Publish::VT_EXCLUDE_ME, Some(true)).unwrap()
  }
  #[inline]
  pub fn exclude(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Publish::VT_EXCLUDE, None)
  }
  #[inline]
  pub fn exclude_authid(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Publish::VT_EXCLUDE_AUTHID, None)
  }
  #[inline]
  pub fn exclude_authrole(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Publish::VT_EXCLUDE_AUTHROLE, None)
  }
  #[inline]
  pub fn eligible(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(Publish::VT_ELIGIBLE, None)
  }
  #[inline]
  pub fn eligible_authid(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Publish::VT_ELIGIBLE_AUTHID, None)
  }
  #[inline]
  pub fn eligible_authrole(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Publish::VT_ELIGIBLE_AUTHROLE, None)
  }
  #[inline]
  pub fn retain(&self) -> bool {
    self._tab.get::<bool>(Publish::VT_RETAIN, Some(false)).unwrap()
  }
  #[inline]
  pub fn transaction_hash(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Publish::VT_TRANSACTION_HASH, None)
  }
  #[inline]
  pub fn forward_for(&self) -> Option<&'a [Principal]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Principal>>>(Publish::VT_FORWARD_FOR, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Publish<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("topic", Self::VT_TOPIC, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("args", Self::VT_ARGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("kwargs", Self::VT_KWARGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<Payload>("enc_algo", Self::VT_ENC_ALGO, false)?
     .visit_field::<Serializer>("enc_serializer", Self::VT_ENC_SERIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("enc_key", Self::VT_ENC_KEY, false)?
     .visit_field::<bool>("acknowledge", Self::VT_ACKNOWLEDGE, false)?
     .visit_field::<bool>("exclude_me", Self::VT_EXCLUDE_ME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("exclude", Self::VT_EXCLUDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("exclude_authid", Self::VT_EXCLUDE_AUTHID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("exclude_authrole", Self::VT_EXCLUDE_AUTHROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("eligible", Self::VT_ELIGIBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("eligible_authid", Self::VT_ELIGIBLE_AUTHID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("eligible_authrole", Self::VT_ELIGIBLE_AUTHROLE, false)?
     .visit_field::<bool>("retain", Self::VT_RETAIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction_hash", Self::VT_TRANSACTION_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Principal>>>("forward_for", Self::VT_FORWARD_FOR, false)?
     .finish();
    Ok(())
  }
}
pub struct PublishArgs<'a> {
    pub request: u64,
    pub topic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub args: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub kwargs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub enc_algo: Payload,
    pub enc_serializer: Serializer,
    pub enc_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub acknowledge: bool,
    pub exclude_me: bool,
    pub exclude: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub exclude_authid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub exclude_authrole: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub eligible: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub eligible_authid: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub eligible_authrole: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub retain: bool,
    pub transaction_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    pub forward_for: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Principal>>>,
}
impl<'a> Default for PublishArgs<'a> {
  #[inline]
  fn default() -> Self {
    PublishArgs {
      request: 0,
      topic: None, // required field
      args: None,
      kwargs: None,
      payload: None,
      enc_algo: Payload::PLAIN,
      enc_serializer: Serializer::TRANSPORT,
      enc_key: None,
      acknowledge: false,
      exclude_me: true,
      exclude: None,
      exclude_authid: None,
      exclude_authrole: None,
      eligible: None,
      eligible_authid: None,
      eligible_authrole: None,
      retain: false,
      transaction_hash: None,
      forward_for: None,
    }
  }
}

pub struct PublishBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PublishBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Publish::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_topic(&mut self, topic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_TOPIC, topic);
  }
  #[inline]
  pub fn add_args(&mut self, args: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_ARGS, args);
  }
  #[inline]
  pub fn add_kwargs(&mut self, kwargs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_KWARGS, kwargs);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_enc_algo(&mut self, enc_algo: Payload) {
    self.fbb_.push_slot::<Payload>(Publish::VT_ENC_ALGO, enc_algo, Payload::PLAIN);
  }
  #[inline]
  pub fn add_enc_serializer(&mut self, enc_serializer: Serializer) {
    self.fbb_.push_slot::<Serializer>(Publish::VT_ENC_SERIALIZER, enc_serializer, Serializer::TRANSPORT);
  }
  #[inline]
  pub fn add_enc_key(&mut self, enc_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_ENC_KEY, enc_key);
  }
  #[inline]
  pub fn add_acknowledge(&mut self, acknowledge: bool) {
    self.fbb_.push_slot::<bool>(Publish::VT_ACKNOWLEDGE, acknowledge, false);
  }
  #[inline]
  pub fn add_exclude_me(&mut self, exclude_me: bool) {
    self.fbb_.push_slot::<bool>(Publish::VT_EXCLUDE_ME, exclude_me, true);
  }
  #[inline]
  pub fn add_exclude(&mut self, exclude: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_EXCLUDE, exclude);
  }
  #[inline]
  pub fn add_exclude_authid(&mut self, exclude_authid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_EXCLUDE_AUTHID, exclude_authid);
  }
  #[inline]
  pub fn add_exclude_authrole(&mut self, exclude_authrole: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_EXCLUDE_AUTHROLE, exclude_authrole);
  }
  #[inline]
  pub fn add_eligible(&mut self, eligible: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_ELIGIBLE, eligible);
  }
  #[inline]
  pub fn add_eligible_authid(&mut self, eligible_authid: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_ELIGIBLE_AUTHID, eligible_authid);
  }
  #[inline]
  pub fn add_eligible_authrole(&mut self, eligible_authrole: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_ELIGIBLE_AUTHROLE, eligible_authrole);
  }
  #[inline]
  pub fn add_retain(&mut self, retain: bool) {
    self.fbb_.push_slot::<bool>(Publish::VT_RETAIN, retain, false);
  }
  #[inline]
  pub fn add_transaction_hash(&mut self, transaction_hash: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_TRANSACTION_HASH, transaction_hash);
  }
  #[inline]
  pub fn add_forward_for(&mut self, forward_for: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Principal>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Publish::VT_FORWARD_FOR, forward_for);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PublishBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PublishBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Publish<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Publish::VT_TOPIC,"topic");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Publish<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Publish");
      ds.field("request", &self.request());
      ds.field("topic", &self.topic());
      ds.field("args", &self.args());
      ds.field("kwargs", &self.kwargs());
      ds.field("payload", &self.payload());
      ds.field("enc_algo", &self.enc_algo());
      ds.field("enc_serializer", &self.enc_serializer());
      ds.field("enc_key", &self.enc_key());
      ds.field("acknowledge", &self.acknowledge());
      ds.field("exclude_me", &self.exclude_me());
      ds.field("exclude", &self.exclude());
      ds.field("exclude_authid", &self.exclude_authid());
      ds.field("exclude_authrole", &self.exclude_authrole());
      ds.field("eligible", &self.eligible());
      ds.field("eligible_authid", &self.eligible_authid());
      ds.field("eligible_authrole", &self.eligible_authrole());
      ds.field("retain", &self.retain());
      ds.field("transaction_hash", &self.transaction_hash());
      ds.field("forward_for", &self.forward_for());
      ds.finish()
  }
}
pub enum PublishedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Published<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Published<'a> {
  type Inner = Published<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Published<'a> {
  pub const VT_REQUEST: flatbuffers::VOffsetT = 4;
  pub const VT_PUBLICATION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Published { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PublishedArgs
  ) -> flatbuffers::WIPOffset<Published<'bldr>> {
    let mut builder = PublishedBuilder::new(_fbb);
    builder.add_publication(args.publication);
    builder.add_request(args.request);
    builder.finish()
  }


  #[inline]
  pub fn request(&self) -> u64 {
    self._tab.get::<u64>(Published::VT_REQUEST, Some(0)).unwrap()
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Published) -> bool {
    self.request() < o.request()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: u64) -> ::core::cmp::Ordering {
    let key = self.request();
    key.cmp(&val)
  }
  #[inline]
  pub fn publication(&self) -> u64 {
    self._tab.get::<u64>(Published::VT_PUBLICATION, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Published<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("request", Self::VT_REQUEST, false)?
     .visit_field::<u64>("publication", Self::VT_PUBLICATION, false)?
     .finish();
    Ok(())
  }
}
pub struct PublishedArgs {
    pub request: u64,
    pub publication: u64,
}
impl<'a> Default for PublishedArgs {
  #[inline]
  fn default() -> Self {
    PublishedArgs {
      request: 0,
      publication: 0,
    }
  }
}

pub struct PublishedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PublishedBuilder<'a, 'b> {
  #[inline]
  pub fn add_request(&mut self, request: u64) {
    self.fbb_.push_slot::<u64>(Published::VT_REQUEST, request, 0);
  }
  #[inline]
  pub fn add_publication(&mut self, publication: u64) {
    self.fbb_.push_slot::<u64>(Published::VT_PUBLICATION, publication, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PublishedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PublishedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Published<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Published<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Published");
      ds.field("request", &self.request());
      ds.field("publication", &self.publication());
      ds.finish()
  }
}
pub enum EventOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Event<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Event<'a> {
  type Inner = Event<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Event<'a> {
  pub const VT_SUBSCRIPTION: flatbuffers::VOffsetT = 4;
  pub const VT_PUBLICATION: flatbuffers::VOffsetT = 6;
  pub const VT_ARGS: flatbuffers::VOffsetT = 8;
  pub const VT_KWARGS: flatbuffers::VOffsetT = 10;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 12;
  pub const VT_ENC_ALGO: flatbuffers::VOffsetT = 14;
  pub const VT_ENC_SERIALIZER: flatbuffers::VOffsetT = 16;
  pub const VT_ENC_KEY: flatbuffers::VOffsetT = 18;
  pub const VT_PUBLISHER: flatbuffers::VOffsetT = 20;
  pub const VT_PUBLISHER_AUTHID: flatbuffers::VOffsetT = 22;
  pub const VT_PUBLISHER_AUTHROLE: flatbuffers::VOffsetT = 24;
  pub const VT_TOPIC: flatbuffers::VOffsetT = 26;
  pub const VT_RETAINED: flatbuffers::VOffsetT = 28;
  pub const VT_TRANSACTION_HASH: flatbuffers::VOffsetT = 30;
  pub const VT_ACKNOWLEDGE: flatbuffers::VOffsetT = 32;
  pub const VT_FORWARD_FOR: flatbuffers::VOffsetT = 34;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Event { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EventArgs<'args>
  ) -> flatbuffers::WIPOffset<Event<'bldr>> {
    let mut builder = EventBuilder::new(_fbb);
    builder.add_publisher(args.publisher);
    builder.add_publication(args.publication);
    builder.add_subscription(args.subscription);
    if let Some(x) = args.forward_for { builder.add_forward_for(x); }
    if let Some(x) = args.transaction_hash { builder.add_transaction_hash(x); }
    if let Some(x) = args.topic { builder.add_topic(x); }
    if let Some(x) = args.publisher_authrole { builder.add_publisher_authrole(x); }
    if let Some(x) = args.publisher_authid { builder.add_publisher_authid(x); }
    if let Some(x) = args.enc_key { builder.add_enc_key(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.kwargs { builder.add_kwargs(x); }
    if let Some(x) = args.args { builder.add_args(x); }
    builder.add_acknowledge(args.acknowledge);
    builder.add_retained(args.retained);
    builder.add_enc_serializer(args.enc_serializer);
    builder.add_enc_algo(args.enc_algo);
    builder.finish()
  }


  #[inline]
  pub fn subscription(&self) -> u64 {
    self._tab.get::<u64>(Event::VT_SUBSCRIPTION, Some(0)).unwrap()
  }
  #[inline]
  pub fn publication(&self) -> u64 {
    self._tab.get::<u64>(Event::VT_PUBLICATION, Some(0)).unwrap()
  }
  /// Positional values for application-defined event payload.
  #[inline]
  pub fn args(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Event::VT_ARGS, None).map(|v| v.safe_slice())
  }
  /// Keyword values for application-defined event payload.
  #[inline]
  pub fn kwargs(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Event::VT_KWARGS, None).map(|v| v.safe_slice())
  }
  /// Alternative, transparent payload. If given, ``args`` and ``kwargs`` must be left unset.
  #[inline]
  pub fn payload(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Event::VT_PAYLOAD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn enc_algo(&self) -> Payload {
    self._tab.get::<Payload>(Event::VT_ENC_ALGO, Some(Payload::PLAIN)).unwrap()
  }
  #[inline]
  pub fn enc_serializer(&self) -> Serializer {
    self._tab.get::<Serializer>(Event::VT_ENC_SERIALIZER, Some(Serializer::TRANSPORT)).unwrap()
  }
  #[inline]
  pub fn enc_key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Event::VT_ENC_KEY, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn publisher(&self) -> u64 {
    self._tab.get::<u64>(Event::VT_PUBLISHER, Some(0)).unwrap()
  }
  #[inline]
  pub fn publisher_authid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Event::VT_PUBLISHER_AUTHID, None)
  }
  #[inline]
  pub fn publisher_authrole(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Event::VT_PUBLISHER_AUTHROLE, None)
  }
  #[inline]
  pub fn topic(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Event::VT_TOPIC, None)
  }
  #[inline]
  pub fn retained(&self) -> bool {
    self._tab.get::<bool>(Event::VT_RETAINED, Some(false)).unwrap()
  }
  #[inline]
  pub fn transaction_hash(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Event::VT_TRANSACTION_HASH, None)
  }
  #[inline]
  pub fn acknowledge(&self) -> bool {
    self._tab.get::<bool>(Event::VT_ACKNOWLEDGE, Some(false)).unwrap()
  }
  #[inline]
  pub fn forward_for(&self) -> Option<&'a [Principal]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Principal>>>(Event::VT_FORWARD_FOR, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Event<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("subscription", Self::VT_SUBSCRIPTION, false)?
     .visit_field::<u64>("publication", Self::VT_PUBLICATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("args", Self::VT_ARGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("kwargs", Self::VT_KWARGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<Payload>("enc_algo", Self::VT_ENC_ALGO, false)?
     .visit_field::<Serializer>("enc_serializer", Self::VT_ENC_SERIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("enc_key", Self::VT_ENC_KEY, false)?
     .visit_field::<u64>("publisher", Self::VT_PUBLISHER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("publisher_authid", Self::VT_PUBLISHER_AUTHID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("publisher_authrole", Self::VT_PUBLISHER_AUTHROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("topic", Self::VT_TOPIC, false)?
     .visit_field::<bool>("retained", Self::VT_RETAINED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transaction_hash", Self::VT_TRANSACTION_HASH, false)?
     .visit_field::<bool>("acknowledge", Self::VT_ACKNOWLEDGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Principal>>>("forward_for", Self::VT_FORWARD_FOR, false)?
     .finish();
    Ok(())
  }
}
pub struct EventArgs<'a> {
    pub subscription: u64,
    pub publication: u64,
    pub args: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub kwargs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub enc_algo: Payload,
    pub enc_serializer: Serializer,
    pub enc_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub publisher: u64,
    pub publisher_authid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub publisher_authrole: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topic: Option<flatbuffers::WIPOffset<&'a str>>,
    pub retained: bool,
    pub transaction_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    pub acknowledge: bool,
    pub forward_for: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Principal>>>,
}
impl<'a> Default for EventArgs<'a> {
  #[inline]
  fn default() -> Self {
    EventArgs {
      subscription: 0,
      publication: 0,
      args: None,
      kwargs: None,
      payload: None,
      enc_algo: Payload::PLAIN,
      enc_serializer: Serializer::TRANSPORT,
      enc_key: None,
      publisher: 0,
      publisher_authid: None,
      publisher_authrole: None,
      topic: None,
      retained: false,
      transaction_hash: None,
      acknowledge: false,
      forward_for: None,
    }
  }
}

pub struct EventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventBuilder<'a, 'b> {
  #[inline]
  pub fn add_subscription(&mut self, subscription: u64) {
    self.fbb_.push_slot::<u64>(Event::VT_SUBSCRIPTION, subscription, 0);
  }
  #[inline]
  pub fn add_publication(&mut self, publication: u64) {
    self.fbb_.push_slot::<u64>(Event::VT_PUBLICATION, publication, 0);
  }
  #[inline]
  pub fn add_args(&mut self, args: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_ARGS, args);
  }
  #[inline]
  pub fn add_kwargs(&mut self, kwargs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_KWARGS, kwargs);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_enc_algo(&mut self, enc_algo: Payload) {
    self.fbb_.push_slot::<Payload>(Event::VT_ENC_ALGO, enc_algo, Payload::PLAIN);
  }
  #[inline]
  pub fn add_enc_serializer(&mut self, enc_serializer: Serializer) {
    self.fbb_.push_slot::<Serializer>(Event::VT_ENC_SERIALIZER, enc_serializer, Serializer::TRANSPORT);
  }
  #[inline]
  pub fn add_enc_key(&mut self, enc_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_ENC_KEY, enc_key);
  }
  #[inline]
  pub fn add_publisher(&mut self, publisher: u64) {
    self.fbb_.push_slot::<u64>(Event::VT_PUBLISHER, publisher, 0);
  }
  #[inline]
  pub fn add_publisher_authid(&mut self, publisher_authid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_PUBLISHER_AUTHID, publisher_authid);
  }
  #[inline]
  pub fn add_publisher_authrole(&mut self, publisher_authrole: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_PUBLISHER_AUTHROLE, publisher_authrole);
  }
  #[inline]
  pub fn add_topic(&mut self, topic: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_TOPIC, topic);
  }
  #[inline]
  pub fn add_retained(&mut self, retained: bool) {
    self.fbb_.push_slot::<bool>(Event::VT_RETAINED, retained, false);
  }
  #[inline]
  pub fn add_transaction_hash(&mut self, transaction_hash: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_TRANSACTION_HASH, transaction_hash);
  }
  #[inline]
  pub fn add_acknowledge(&mut self, acknowledge: bool) {
    self.fbb_.push_slot::<bool>(Event::VT_ACKNOWLEDGE, acknowledge, false);
  }
  #[inline]
  pub fn add_forward_for(&mut self, forward_for: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Principal>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Event::VT_FORWARD_FOR, forward_for);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Event<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Event<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Event");
      ds.field("subscription", &self.subscription());
      ds.field("publication", &self.publication());
      ds.field("args", &self.args());
      ds.field("kwargs", &self.kwargs());
      ds.field("payload", &self.payload());
      ds.field("enc_algo", &self.enc_algo());
      ds.field("enc_serializer", &self.enc_serializer());
      ds.field("enc_key", &self.enc_key());
      ds.field("publisher", &self.publisher());
      ds.field("publisher_authid", &self.publisher_authid());
      ds.field("publisher_authrole", &self.publisher_authrole());
      ds.field("topic", &self.topic());
      ds.field("retained", &self.retained());
      ds.field("transaction_hash", &self.transaction_hash());
      ds.field("acknowledge", &self.acknowledge());
      ds.field("forward_for", &self.forward_for());
      ds.finish()
  }
}
pub enum EventReceivedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EventReceived<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventReceived<'a> {
  type Inner = EventReceived<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> EventReceived<'a> {
  pub const VT_PUBLICATION: flatbuffers::VOffsetT = 4;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 6;
  pub const VT_ENC_ALGO: flatbuffers::VOffsetT = 8;
  pub const VT_ENC_SERIALIZER: flatbuffers::VOffsetT = 10;
  pub const VT_ENC_KEY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EventReceived { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EventReceivedArgs<'args>
  ) -> flatbuffers::WIPOffset<EventReceived<'bldr>> {
    let mut builder = EventReceivedBuilder::new(_fbb);
    builder.add_publication(args.publication);
    if let Some(x) = args.enc_key { builder.add_enc_key(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    builder.add_enc_serializer(args.enc_serializer);
    builder.add_enc_algo(args.enc_algo);
    builder.finish()
  }


  #[inline]
  pub fn publication(&self) -> u64 {
    self._tab.get::<u64>(EventReceived::VT_PUBLICATION, Some(0)).unwrap()
  }
  #[inline]
  pub fn payload(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(EventReceived::VT_PAYLOAD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn enc_algo(&self) -> Payload {
    self._tab.get::<Payload>(EventReceived::VT_ENC_ALGO, Some(Payload::PLAIN)).unwrap()
  }
  #[inline]
  pub fn enc_serializer(&self) -> Serializer {
    self._tab.get::<Serializer>(EventReceived::VT_ENC_SERIALIZER, Some(Serializer::TRANSPORT)).unwrap()
  }
  #[inline]
  pub fn enc_key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(EventReceived::VT_ENC_KEY, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for EventReceived<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("publication", Self::VT_PUBLICATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<Payload>("enc_algo", Self::VT_ENC_ALGO, false)?
     .visit_field::<Serializer>("enc_serializer", Self::VT_ENC_SERIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("enc_key", Self::VT_ENC_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct EventReceivedArgs<'a> {
    pub publication: u64,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub enc_algo: Payload,
    pub enc_serializer: Serializer,
    pub enc_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for EventReceivedArgs<'a> {
  #[inline]
  fn default() -> Self {
    EventReceivedArgs {
      publication: 0,
      payload: None,
      enc_algo: Payload::PLAIN,
      enc_serializer: Serializer::TRANSPORT,
      enc_key: None,
    }
  }
}

pub struct EventReceivedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventReceivedBuilder<'a, 'b> {
  #[inline]
  pub fn add_publication(&mut self, publication: u64) {
    self.fbb_.push_slot::<u64>(EventReceived::VT_PUBLICATION, publication, 0);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventReceived::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_enc_algo(&mut self, enc_algo: Payload) {
    self.fbb_.push_slot::<Payload>(EventReceived::VT_ENC_ALGO, enc_algo, Payload::PLAIN);
  }
  #[inline]
  pub fn add_enc_serializer(&mut self, enc_serializer: Serializer) {
    self.fbb_.push_slot::<Serializer>(EventReceived::VT_ENC_SERIALIZER, enc_serializer, Serializer::TRANSPORT);
  }
  #[inline]
  pub fn add_enc_key(&mut self, enc_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventReceived::VT_ENC_KEY, enc_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EventReceivedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EventReceivedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EventReceived<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EventReceived<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EventReceived");
      ds.field("publication", &self.publication());
      ds.field("payload", &self.payload());
      ds.field("enc_algo", &self.enc_algo());
      ds.field("enc_serializer", &self.enc_serializer());
      ds.field("enc_key", &self.enc_key());
      ds.finish()
  }
}
pub enum SubscriberReceivedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubscriberReceived<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubscriberReceived<'a> {
  type Inner = SubscriberReceived<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SubscriberReceived<'a> {
  pub const VT_PUBLICATION: flatbuffers::VOffsetT = 4;
  pub const VT_SUBSCRIBER: flatbuffers::VOffsetT = 6;
  pub const VT_SUBSCRIBER_AUTHID: flatbuffers::VOffsetT = 8;
  pub const VT_SUBSCRIBER_AUTHROLE: flatbuffers::VOffsetT = 10;
  pub const VT_PAYLOAD: flatbuffers::VOffsetT = 12;
  pub const VT_ENC_ALGO: flatbuffers::VOffsetT = 14;
  pub const VT_ENC_SERIALIZER: flatbuffers::VOffsetT = 16;
  pub const VT_ENC_KEY: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubscriberReceived { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubscriberReceivedArgs<'args>
  ) -> flatbuffers::WIPOffset<SubscriberReceived<'bldr>> {
    let mut builder = SubscriberReceivedBuilder::new(_fbb);
    builder.add_subscriber(args.subscriber);
    builder.add_publication(args.publication);
    if let Some(x) = args.enc_key { builder.add_enc_key(x); }
    if let Some(x) = args.payload { builder.add_payload(x); }
    if let Some(x) = args.subscriber_authrole { builder.add_subscriber_authrole(x); }
    if let Some(x) = args.subscriber_authid { builder.add_subscriber_authid(x); }
    builder.add_enc_serializer(args.enc_serializer);
    builder.add_enc_algo(args.enc_algo);
    builder.finish()
  }


  #[inline]
  pub fn publication(&self) -> u64 {
    self._tab.get::<u64>(SubscriberReceived::VT_PUBLICATION, Some(0)).unwrap()
  }
  #[inline]
  pub fn subscriber(&self) -> u64 {
    self._tab.get::<u64>(SubscriberReceived::VT_SUBSCRIBER, Some(0)).unwrap()
  }
  #[inline]
  pub fn subscriber_authid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubscriberReceived::VT_SUBSCRIBER_AUTHID, None)
  }
  #[inline]
  pub fn subscriber_authrole(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubscriberReceived::VT_SUBSCRIBER_AUTHROLE, None)
  }
  #[inline]
  pub fn payload(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SubscriberReceived::VT_PAYLOAD, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn enc_algo(&self) -> Payload {
    self._tab.get::<Payload>(SubscriberReceived::VT_ENC_ALGO, Some(Payload::PLAIN)).unwrap()
  }
  #[inline]
  pub fn enc_serializer(&self) -> Serializer {
    self._tab.get::<Serializer>(SubscriberReceived::VT_ENC_SERIALIZER, Some(Serializer::TRANSPORT)).unwrap()
  }
  #[inline]
  pub fn enc_key(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(SubscriberReceived::VT_ENC_KEY, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for SubscriberReceived<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("publication", Self::VT_PUBLICATION, false)?
     .visit_field::<u64>("subscriber", Self::VT_SUBSCRIBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subscriber_authid", Self::VT_SUBSCRIBER_AUTHID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("subscriber_authrole", Self::VT_SUBSCRIBER_AUTHROLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .visit_field::<Payload>("enc_algo", Self::VT_ENC_ALGO, false)?
     .visit_field::<Serializer>("enc_serializer", Self::VT_ENC_SERIALIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("enc_key", Self::VT_ENC_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscriberReceivedArgs<'a> {
    pub publication: u64,
    pub subscriber: u64,
    pub subscriber_authid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub subscriber_authrole: Option<flatbuffers::WIPOffset<&'a str>>,
    pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub enc_algo: Payload,
    pub enc_serializer: Serializer,
    pub enc_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for SubscriberReceivedArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubscriberReceivedArgs {
      publication: 0,
      subscriber: 0,
      subscriber_authid: None,
      subscriber_authrole: None,
      payload: None,
      enc_algo: Payload::PLAIN,
      enc_serializer: Serializer::TRANSPORT,
      enc_key: None,
    }
  }
}

pub struct SubscriberReceivedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubscriberReceivedBuilder<'a, 'b> {
  #[inline]
  pub fn add_publication(&mut self, publication: u64) {
    self.fbb_.push_slot::<u64>(SubscriberReceived::VT_PUBLICATION, publication, 0);
  }
  #[inline]
  pub fn add_subscriber(&mut self, subscriber: u64) {
    self.fbb_.push_slot::<u64>(SubscriberReceived::VT_SUBSCRIBER, subscriber, 0);
  }
  #[inline]
  pub fn add_subscriber_authid(&mut self, subscriber_authid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscriberReceived::VT_SUBSCRIBER_AUTHID, subscriber_authid);
  }
  #[inline]
  pub fn add_subscriber_authrole(&mut self, subscriber_authrole: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscriberReceived::VT_SUBSCRIBER_AUTHROLE, subscriber_authrole);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscriberReceived::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn add_enc_algo(&mut self, enc_algo: Payload) {
    self.fbb_.push_slot::<Payload>(SubscriberReceived::VT_ENC_ALGO, enc_algo, Payload::PLAIN);
  }
  #[inline]
  pub fn add_enc_serializer(&mut self, enc_serializer: Serializer) {
    self.fbb_.push_slot::<Serializer>(SubscriberReceived::VT_ENC_SERIALIZER, enc_serializer, Serializer::TRANSPORT);
  }
  #[inline]
  pub fn add_enc_key(&mut self, enc_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubscriberReceived::VT_ENC_KEY, enc_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubscriberReceivedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubscriberReceivedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubscriberReceived<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubscriberReceived<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubscriberReceived");
      ds.field("publication", &self.publication());
      ds.field("subscriber", &self.subscriber());
      ds.field("subscriber_authid", &self.subscriber_authid());
      ds.field("subscriber_authrole", &self.subscriber_authrole());
      ds.field("payload", &self.payload());
      ds.field("enc_algo", &self.enc_algo());
      ds.field("enc_serializer", &self.enc_serializer());
      ds.field("enc_key", &self.enc_key());
      ds.finish()
  }
}
}  // pub mod proto
}  // pub mod wamp

