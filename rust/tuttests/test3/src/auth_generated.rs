// automatically generated by the FlatBuffers compiler, do not modify


use crate::types_generated::*;
use crate::roles_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod wamp {

  use crate::types_generated::*;
  use crate::roles_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod proto {

  use crate::types_generated::*;
  use crate::roles_generated::*;
  use crate::roles_generated::wamp::proto::ClientRoles;

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AUTH_METHOD: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AUTH_METHOD: u8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AUTH_METHOD: [AuthMethod; 7] = [
  AuthMethod::ANONYMOUS,
  AuthMethod::COOKIE,
  AuthMethod::TLS,
  AuthMethod::TICKET,
  AuthMethod::CRA,
  AuthMethod::SCRAM,
  AuthMethod::CRYPTOSIGN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AuthMethod(pub u8);
#[allow(non_upper_case_globals)]
impl AuthMethod {
  pub const ANONYMOUS: Self = Self(0);
  pub const COOKIE: Self = Self(1);
  pub const TLS: Self = Self(2);
  pub const TICKET: Self = Self(3);
  pub const CRA: Self = Self(4);
  pub const SCRAM: Self = Self(5);
  pub const CRYPTOSIGN: Self = Self(6);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ANONYMOUS,
    Self::COOKIE,
    Self::TLS,
    Self::TICKET,
    Self::CRA,
    Self::SCRAM,
    Self::CRYPTOSIGN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ANONYMOUS => Some("ANONYMOUS"),
      Self::COOKIE => Some("COOKIE"),
      Self::TLS => Some("TLS"),
      Self::TICKET => Some("TICKET"),
      Self::CRA => Some("CRA"),
      Self::SCRAM => Some("SCRAM"),
      Self::CRYPTOSIGN => Some("CRYPTOSIGN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AuthMethod {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AuthMethod {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for AuthMethod {
    type Output = AuthMethod;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for AuthMethod {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AuthMethod {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AuthMethod {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CHANNEL_BINDING: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CHANNEL_BINDING: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CHANNEL_BINDING: [ChannelBinding; 2] = [
  ChannelBinding::NONE,
  ChannelBinding::TLS_UNIQUE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ChannelBinding(pub u8);
#[allow(non_upper_case_globals)]
impl ChannelBinding {
  pub const NONE: Self = Self(0);
  pub const TLS_UNIQUE: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::TLS_UNIQUE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::TLS_UNIQUE => Some("TLS_UNIQUE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ChannelBinding {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ChannelBinding {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for ChannelBinding {
    type Output = ChannelBinding;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ChannelBinding {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ChannelBinding {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ChannelBinding {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_KDF: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_KDF: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_KDF: [Kdf; 3] = [
  Kdf::NONE,
  Kdf::PBKDF2,
  Kdf::ARGON2,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Kdf(pub u8);
#[allow(non_upper_case_globals)]
impl Kdf {
  pub const NONE: Self = Self(0);
  pub const PBKDF2: Self = Self(1);
  pub const ARGON2: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PBKDF2,
    Self::ARGON2,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PBKDF2 => Some("PBKDF2"),
      Self::ARGON2 => Some("ARGON2"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Kdf {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Kdf {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Kdf {
    type Output = Kdf;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Kdf {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Kdf {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Kdf {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AUTH_FACTOR: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AUTH_FACTOR: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AUTH_FACTOR: [AuthFactor; 5] = [
  AuthFactor::NONE,
  AuthFactor::AuthTicketRequest,
  AuthFactor::AuthCraRequest,
  AuthFactor::AuthScramRequest,
  AuthFactor::AuthCryptosignRequest,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AuthFactor(pub u8);
#[allow(non_upper_case_globals)]
impl AuthFactor {
  pub const NONE: Self = Self(0);
  pub const AuthTicketRequest: Self = Self(1);
  pub const AuthCraRequest: Self = Self(2);
  pub const AuthScramRequest: Self = Self(3);
  pub const AuthCryptosignRequest: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::AuthTicketRequest,
    Self::AuthCraRequest,
    Self::AuthScramRequest,
    Self::AuthCryptosignRequest,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::AuthTicketRequest => Some("AuthTicketRequest"),
      Self::AuthCraRequest => Some("AuthCraRequest"),
      Self::AuthScramRequest => Some("AuthScramRequest"),
      Self::AuthCryptosignRequest => Some("AuthCryptosignRequest"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AuthFactor {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AuthFactor {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for AuthFactor {
    type Output = AuthFactor;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for AuthFactor {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AuthFactor {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AuthFactor {}
pub struct AuthFactorUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AUTH_MODE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AUTH_MODE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AUTH_MODE: [AuthMode; 2] = [
  AuthMode::FIRST,
  AuthMode::MULTIFACTOR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AuthMode(pub u8);
#[allow(non_upper_case_globals)]
impl AuthMode {
  pub const FIRST: Self = Self(0);
  pub const MULTIFACTOR: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FIRST,
    Self::MULTIFACTOR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FIRST => Some("FIRST"),
      Self::MULTIFACTOR => Some("MULTIFACTOR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AuthMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AuthMode {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for AuthMode {
    type Output = AuthMode;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for AuthMode {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AuthMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AuthMode {}
pub enum AuthTicketRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthTicketRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthTicketRequest<'a> {
  type Inner = AuthTicketRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthTicketRequest<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthTicketRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AuthTicketRequestArgs
  ) -> flatbuffers::WIPOffset<AuthTicketRequest<'bldr>> {
    let mut builder = AuthTicketRequestBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for AuthTicketRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AuthTicketRequestArgs {
}
impl<'a> Default for AuthTicketRequestArgs {
  #[inline]
  fn default() -> Self {
    AuthTicketRequestArgs {
    }
  }
}

pub struct AuthTicketRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthTicketRequestBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthTicketRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthTicketRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthTicketRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthTicketRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthTicketRequest");
      ds.finish()
  }
}
pub enum AuthTicketChallengeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthTicketChallenge<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthTicketChallenge<'a> {
  type Inner = AuthTicketChallenge<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthTicketChallenge<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthTicketChallenge { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AuthTicketChallengeArgs
  ) -> flatbuffers::WIPOffset<AuthTicketChallenge<'bldr>> {
    let mut builder = AuthTicketChallengeBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for AuthTicketChallenge<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AuthTicketChallengeArgs {
}
impl<'a> Default for AuthTicketChallengeArgs {
  #[inline]
  fn default() -> Self {
    AuthTicketChallengeArgs {
    }
  }
}

pub struct AuthTicketChallengeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthTicketChallengeBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthTicketChallengeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthTicketChallengeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthTicketChallenge<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthTicketChallenge<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthTicketChallenge");
      ds.finish()
  }
}
pub enum AuthTicketWelcomeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthTicketWelcome<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthTicketWelcome<'a> {
  type Inner = AuthTicketWelcome<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthTicketWelcome<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthTicketWelcome { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AuthTicketWelcomeArgs
  ) -> flatbuffers::WIPOffset<AuthTicketWelcome<'bldr>> {
    let mut builder = AuthTicketWelcomeBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for AuthTicketWelcome<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AuthTicketWelcomeArgs {
}
impl<'a> Default for AuthTicketWelcomeArgs {
  #[inline]
  fn default() -> Self {
    AuthTicketWelcomeArgs {
    }
  }
}

pub struct AuthTicketWelcomeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthTicketWelcomeBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthTicketWelcomeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthTicketWelcomeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthTicketWelcome<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthTicketWelcome<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthTicketWelcome");
      ds.finish()
  }
}
pub enum AuthCraRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthCraRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthCraRequest<'a> {
  type Inner = AuthCraRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthCraRequest<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthCraRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AuthCraRequestArgs
  ) -> flatbuffers::WIPOffset<AuthCraRequest<'bldr>> {
    let mut builder = AuthCraRequestBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for AuthCraRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AuthCraRequestArgs {
}
impl<'a> Default for AuthCraRequestArgs {
  #[inline]
  fn default() -> Self {
    AuthCraRequestArgs {
    }
  }
}

pub struct AuthCraRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthCraRequestBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthCraRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthCraRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthCraRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthCraRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthCraRequest");
      ds.finish()
  }
}
pub enum AuthCraChallengeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthCraChallenge<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthCraChallenge<'a> {
  type Inner = AuthCraChallenge<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthCraChallenge<'a> {
  pub const VT_CHALLENGE: flatbuffers::VOffsetT = 4;
  pub const VT_SALT: flatbuffers::VOffsetT = 6;
  pub const VT_ITERATIONS: flatbuffers::VOffsetT = 8;
  pub const VT_KEYLEN: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthCraChallenge { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AuthCraChallengeArgs<'args>
  ) -> flatbuffers::WIPOffset<AuthCraChallenge<'bldr>> {
    let mut builder = AuthCraChallengeBuilder::new(_fbb);
    builder.add_iterations(args.iterations);
    if let Some(x) = args.salt { builder.add_salt(x); }
    if let Some(x) = args.challenge { builder.add_challenge(x); }
    builder.add_keylen(args.keylen);
    builder.finish()
  }


  #[inline]
  pub fn challenge(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AuthCraChallenge::VT_CHALLENGE, None).unwrap()
  }
  #[inline]
  pub fn salt(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AuthCraChallenge::VT_SALT, None)
  }
  #[inline]
  pub fn iterations(&self) -> u32 {
    self._tab.get::<u32>(AuthCraChallenge::VT_ITERATIONS, Some(1000)).unwrap()
  }
  #[inline]
  pub fn keylen(&self) -> u8 {
    self._tab.get::<u8>(AuthCraChallenge::VT_KEYLEN, Some(32)).unwrap()
  }
}

impl flatbuffers::Verifiable for AuthCraChallenge<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("challenge", Self::VT_CHALLENGE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("salt", Self::VT_SALT, false)?
     .visit_field::<u32>("iterations", Self::VT_ITERATIONS, false)?
     .visit_field::<u8>("keylen", Self::VT_KEYLEN, false)?
     .finish();
    Ok(())
  }
}
pub struct AuthCraChallengeArgs<'a> {
    pub challenge: Option<flatbuffers::WIPOffset<&'a str>>,
    pub salt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub iterations: u32,
    pub keylen: u8,
}
impl<'a> Default for AuthCraChallengeArgs<'a> {
  #[inline]
  fn default() -> Self {
    AuthCraChallengeArgs {
      challenge: None, // required field
      salt: None,
      iterations: 1000,
      keylen: 32,
    }
  }
}

pub struct AuthCraChallengeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthCraChallengeBuilder<'a, 'b> {
  #[inline]
  pub fn add_challenge(&mut self, challenge: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AuthCraChallenge::VT_CHALLENGE, challenge);
  }
  #[inline]
  pub fn add_salt(&mut self, salt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AuthCraChallenge::VT_SALT, salt);
  }
  #[inline]
  pub fn add_iterations(&mut self, iterations: u32) {
    self.fbb_.push_slot::<u32>(AuthCraChallenge::VT_ITERATIONS, iterations, 1000);
  }
  #[inline]
  pub fn add_keylen(&mut self, keylen: u8) {
    self.fbb_.push_slot::<u8>(AuthCraChallenge::VT_KEYLEN, keylen, 32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthCraChallengeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthCraChallengeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthCraChallenge<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, AuthCraChallenge::VT_CHALLENGE,"challenge");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthCraChallenge<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthCraChallenge");
      ds.field("challenge", &self.challenge());
      ds.field("salt", &self.salt());
      ds.field("iterations", &self.iterations());
      ds.field("keylen", &self.keylen());
      ds.finish()
  }
}
pub enum AuthCraWelcomeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthCraWelcome<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthCraWelcome<'a> {
  type Inner = AuthCraWelcome<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthCraWelcome<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthCraWelcome { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AuthCraWelcomeArgs
  ) -> flatbuffers::WIPOffset<AuthCraWelcome<'bldr>> {
    let mut builder = AuthCraWelcomeBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for AuthCraWelcome<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AuthCraWelcomeArgs {
}
impl<'a> Default for AuthCraWelcomeArgs {
  #[inline]
  fn default() -> Self {
    AuthCraWelcomeArgs {
    }
  }
}

pub struct AuthCraWelcomeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthCraWelcomeBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthCraWelcomeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthCraWelcomeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthCraWelcome<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthCraWelcome<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthCraWelcome");
      ds.finish()
  }
}
pub enum AuthScramRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthScramRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthScramRequest<'a> {
  type Inner = AuthScramRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthScramRequest<'a> {
  pub const VT_NONCE: flatbuffers::VOffsetT = 4;
  pub const VT_CHANNEL_BINDING: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthScramRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AuthScramRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<AuthScramRequest<'bldr>> {
    let mut builder = AuthScramRequestBuilder::new(_fbb);
    if let Some(x) = args.nonce { builder.add_nonce(x); }
    builder.add_channel_binding(args.channel_binding);
    builder.finish()
  }


  #[inline]
  pub fn nonce(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AuthScramRequest::VT_NONCE, None).unwrap()
  }
  #[inline]
  pub fn channel_binding(&self) -> ChannelBinding {
    self._tab.get::<ChannelBinding>(AuthScramRequest::VT_CHANNEL_BINDING, Some(ChannelBinding::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for AuthScramRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nonce", Self::VT_NONCE, true)?
     .visit_field::<ChannelBinding>("channel_binding", Self::VT_CHANNEL_BINDING, false)?
     .finish();
    Ok(())
  }
}
pub struct AuthScramRequestArgs<'a> {
    pub nonce: Option<flatbuffers::WIPOffset<&'a str>>,
    pub channel_binding: ChannelBinding,
}
impl<'a> Default for AuthScramRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    AuthScramRequestArgs {
      nonce: None, // required field
      channel_binding: ChannelBinding::NONE,
    }
  }
}

pub struct AuthScramRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthScramRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_nonce(&mut self, nonce: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AuthScramRequest::VT_NONCE, nonce);
  }
  #[inline]
  pub fn add_channel_binding(&mut self, channel_binding: ChannelBinding) {
    self.fbb_.push_slot::<ChannelBinding>(AuthScramRequest::VT_CHANNEL_BINDING, channel_binding, ChannelBinding::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthScramRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthScramRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthScramRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, AuthScramRequest::VT_NONCE,"nonce");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthScramRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthScramRequest");
      ds.field("nonce", &self.nonce());
      ds.field("channel_binding", &self.channel_binding());
      ds.finish()
  }
}
pub enum AuthScramChallengeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthScramChallenge<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthScramChallenge<'a> {
  type Inner = AuthScramChallenge<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthScramChallenge<'a> {
  pub const VT_NONCE: flatbuffers::VOffsetT = 4;
  pub const VT_SALT: flatbuffers::VOffsetT = 6;
  pub const VT_KDF: flatbuffers::VOffsetT = 8;
  pub const VT_ITERATIONS: flatbuffers::VOffsetT = 10;
  pub const VT_MEMORY: flatbuffers::VOffsetT = 12;
  pub const VT_CHANNEL_BINDING: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthScramChallenge { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AuthScramChallengeArgs<'args>
  ) -> flatbuffers::WIPOffset<AuthScramChallenge<'bldr>> {
    let mut builder = AuthScramChallengeBuilder::new(_fbb);
    builder.add_memory(args.memory);
    builder.add_iterations(args.iterations);
    if let Some(x) = args.salt { builder.add_salt(x); }
    if let Some(x) = args.nonce { builder.add_nonce(x); }
    builder.add_channel_binding(args.channel_binding);
    builder.add_kdf(args.kdf);
    builder.finish()
  }


  #[inline]
  pub fn nonce(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AuthScramChallenge::VT_NONCE, None).unwrap()
  }
  #[inline]
  pub fn salt(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AuthScramChallenge::VT_SALT, None).unwrap()
  }
  #[inline]
  pub fn kdf(&self) -> Kdf {
    self._tab.get::<Kdf>(AuthScramChallenge::VT_KDF, Some(Kdf::ARGON2)).unwrap()
  }
  #[inline]
  pub fn iterations(&self) -> u32 {
    self._tab.get::<u32>(AuthScramChallenge::VT_ITERATIONS, Some(0)).unwrap()
  }
  #[inline]
  pub fn memory(&self) -> u32 {
    self._tab.get::<u32>(AuthScramChallenge::VT_MEMORY, Some(0)).unwrap()
  }
  #[inline]
  pub fn channel_binding(&self) -> ChannelBinding {
    self._tab.get::<ChannelBinding>(AuthScramChallenge::VT_CHANNEL_BINDING, Some(ChannelBinding::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for AuthScramChallenge<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nonce", Self::VT_NONCE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("salt", Self::VT_SALT, true)?
     .visit_field::<Kdf>("kdf", Self::VT_KDF, false)?
     .visit_field::<u32>("iterations", Self::VT_ITERATIONS, false)?
     .visit_field::<u32>("memory", Self::VT_MEMORY, false)?
     .visit_field::<ChannelBinding>("channel_binding", Self::VT_CHANNEL_BINDING, false)?
     .finish();
    Ok(())
  }
}
pub struct AuthScramChallengeArgs<'a> {
    pub nonce: Option<flatbuffers::WIPOffset<&'a str>>,
    pub salt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kdf: Kdf,
    pub iterations: u32,
    pub memory: u32,
    pub channel_binding: ChannelBinding,
}
impl<'a> Default for AuthScramChallengeArgs<'a> {
  #[inline]
  fn default() -> Self {
    AuthScramChallengeArgs {
      nonce: None, // required field
      salt: None, // required field
      kdf: Kdf::ARGON2,
      iterations: 0,
      memory: 0,
      channel_binding: ChannelBinding::NONE,
    }
  }
}

pub struct AuthScramChallengeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthScramChallengeBuilder<'a, 'b> {
  #[inline]
  pub fn add_nonce(&mut self, nonce: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AuthScramChallenge::VT_NONCE, nonce);
  }
  #[inline]
  pub fn add_salt(&mut self, salt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AuthScramChallenge::VT_SALT, salt);
  }
  #[inline]
  pub fn add_kdf(&mut self, kdf: Kdf) {
    self.fbb_.push_slot::<Kdf>(AuthScramChallenge::VT_KDF, kdf, Kdf::ARGON2);
  }
  #[inline]
  pub fn add_iterations(&mut self, iterations: u32) {
    self.fbb_.push_slot::<u32>(AuthScramChallenge::VT_ITERATIONS, iterations, 0);
  }
  #[inline]
  pub fn add_memory(&mut self, memory: u32) {
    self.fbb_.push_slot::<u32>(AuthScramChallenge::VT_MEMORY, memory, 0);
  }
  #[inline]
  pub fn add_channel_binding(&mut self, channel_binding: ChannelBinding) {
    self.fbb_.push_slot::<ChannelBinding>(AuthScramChallenge::VT_CHANNEL_BINDING, channel_binding, ChannelBinding::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthScramChallengeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthScramChallengeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthScramChallenge<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, AuthScramChallenge::VT_NONCE,"nonce");
    self.fbb_.required(o, AuthScramChallenge::VT_SALT,"salt");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthScramChallenge<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthScramChallenge");
      ds.field("nonce", &self.nonce());
      ds.field("salt", &self.salt());
      ds.field("kdf", &self.kdf());
      ds.field("iterations", &self.iterations());
      ds.field("memory", &self.memory());
      ds.field("channel_binding", &self.channel_binding());
      ds.finish()
  }
}
pub enum AuthScramWelcomeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthScramWelcome<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthScramWelcome<'a> {
  type Inner = AuthScramWelcome<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthScramWelcome<'a> {
  pub const VT_VERIFIER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthScramWelcome { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AuthScramWelcomeArgs<'args>
  ) -> flatbuffers::WIPOffset<AuthScramWelcome<'bldr>> {
    let mut builder = AuthScramWelcomeBuilder::new(_fbb);
    if let Some(x) = args.verifier { builder.add_verifier(x); }
    builder.finish()
  }


  #[inline]
  pub fn verifier(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AuthScramWelcome::VT_VERIFIER, None)
  }
}

impl flatbuffers::Verifiable for AuthScramWelcome<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("verifier", Self::VT_VERIFIER, false)?
     .finish();
    Ok(())
  }
}
pub struct AuthScramWelcomeArgs<'a> {
    pub verifier: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AuthScramWelcomeArgs<'a> {
  #[inline]
  fn default() -> Self {
    AuthScramWelcomeArgs {
      verifier: None,
    }
  }
}

pub struct AuthScramWelcomeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthScramWelcomeBuilder<'a, 'b> {
  #[inline]
  pub fn add_verifier(&mut self, verifier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AuthScramWelcome::VT_VERIFIER, verifier);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthScramWelcomeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthScramWelcomeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthScramWelcome<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthScramWelcome<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthScramWelcome");
      ds.field("verifier", &self.verifier());
      ds.finish()
  }
}
pub enum AuthCryptosignRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthCryptosignRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthCryptosignRequest<'a> {
  type Inner = AuthCryptosignRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthCryptosignRequest<'a> {
  pub const VT_PUBKEY: flatbuffers::VOffsetT = 4;
  pub const VT_CHANNEL_BINDING: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthCryptosignRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AuthCryptosignRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<AuthCryptosignRequest<'bldr>> {
    let mut builder = AuthCryptosignRequestBuilder::new(_fbb);
    if let Some(x) = args.pubkey { builder.add_pubkey(x); }
    builder.add_channel_binding(args.channel_binding);
    builder.finish()
  }


  #[inline]
  pub fn pubkey(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AuthCryptosignRequest::VT_PUBKEY, None).unwrap()
  }
  #[inline]
  pub fn channel_binding(&self) -> ChannelBinding {
    self._tab.get::<ChannelBinding>(AuthCryptosignRequest::VT_CHANNEL_BINDING, Some(ChannelBinding::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for AuthCryptosignRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pubkey", Self::VT_PUBKEY, true)?
     .visit_field::<ChannelBinding>("channel_binding", Self::VT_CHANNEL_BINDING, false)?
     .finish();
    Ok(())
  }
}
pub struct AuthCryptosignRequestArgs<'a> {
    pub pubkey: Option<flatbuffers::WIPOffset<&'a str>>,
    pub channel_binding: ChannelBinding,
}
impl<'a> Default for AuthCryptosignRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    AuthCryptosignRequestArgs {
      pubkey: None, // required field
      channel_binding: ChannelBinding::NONE,
    }
  }
}

pub struct AuthCryptosignRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthCryptosignRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_pubkey(&mut self, pubkey: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AuthCryptosignRequest::VT_PUBKEY, pubkey);
  }
  #[inline]
  pub fn add_channel_binding(&mut self, channel_binding: ChannelBinding) {
    self.fbb_.push_slot::<ChannelBinding>(AuthCryptosignRequest::VT_CHANNEL_BINDING, channel_binding, ChannelBinding::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthCryptosignRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthCryptosignRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthCryptosignRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, AuthCryptosignRequest::VT_PUBKEY,"pubkey");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthCryptosignRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthCryptosignRequest");
      ds.field("pubkey", &self.pubkey());
      ds.field("channel_binding", &self.channel_binding());
      ds.finish()
  }
}
pub enum AuthCryptosignChallengeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthCryptosignChallenge<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthCryptosignChallenge<'a> {
  type Inner = AuthCryptosignChallenge<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthCryptosignChallenge<'a> {
  pub const VT_CHANNEL_BINDING: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthCryptosignChallenge { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AuthCryptosignChallengeArgs
  ) -> flatbuffers::WIPOffset<AuthCryptosignChallenge<'bldr>> {
    let mut builder = AuthCryptosignChallengeBuilder::new(_fbb);
    builder.add_channel_binding(args.channel_binding);
    builder.finish()
  }


  #[inline]
  pub fn channel_binding(&self) -> ChannelBinding {
    self._tab.get::<ChannelBinding>(AuthCryptosignChallenge::VT_CHANNEL_BINDING, Some(ChannelBinding::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for AuthCryptosignChallenge<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ChannelBinding>("channel_binding", Self::VT_CHANNEL_BINDING, false)?
     .finish();
    Ok(())
  }
}
pub struct AuthCryptosignChallengeArgs {
    pub channel_binding: ChannelBinding,
}
impl<'a> Default for AuthCryptosignChallengeArgs {
  #[inline]
  fn default() -> Self {
    AuthCryptosignChallengeArgs {
      channel_binding: ChannelBinding::NONE,
    }
  }
}

pub struct AuthCryptosignChallengeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthCryptosignChallengeBuilder<'a, 'b> {
  #[inline]
  pub fn add_channel_binding(&mut self, channel_binding: ChannelBinding) {
    self.fbb_.push_slot::<ChannelBinding>(AuthCryptosignChallenge::VT_CHANNEL_BINDING, channel_binding, ChannelBinding::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthCryptosignChallengeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthCryptosignChallengeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthCryptosignChallenge<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthCryptosignChallenge<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthCryptosignChallenge");
      ds.field("channel_binding", &self.channel_binding());
      ds.finish()
  }
}
pub enum AuthCryptosignWelcomeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AuthCryptosignWelcome<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AuthCryptosignWelcome<'a> {
  type Inner = AuthCryptosignWelcome<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AuthCryptosignWelcome<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AuthCryptosignWelcome { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AuthCryptosignWelcomeArgs
  ) -> flatbuffers::WIPOffset<AuthCryptosignWelcome<'bldr>> {
    let mut builder = AuthCryptosignWelcomeBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for AuthCryptosignWelcome<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AuthCryptosignWelcomeArgs {
}
impl<'a> Default for AuthCryptosignWelcomeArgs {
  #[inline]
  fn default() -> Self {
    AuthCryptosignWelcomeArgs {
    }
  }
}

pub struct AuthCryptosignWelcomeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AuthCryptosignWelcomeBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AuthCryptosignWelcomeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AuthCryptosignWelcomeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AuthCryptosignWelcome<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AuthCryptosignWelcome<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AuthCryptosignWelcome");
      ds.finish()
  }
}
pub enum HelloNewOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HelloNew<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HelloNew<'a> {
  type Inner = HelloNew<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> HelloNew<'a> {
  pub const VT_ROLES: flatbuffers::VOffsetT = 4;
  pub const VT_REALM: flatbuffers::VOffsetT = 6;
  pub const VT_AUTHID: flatbuffers::VOffsetT = 8;
  pub const VT_AUTHROLE: flatbuffers::VOffsetT = 10;
  pub const VT_AUTHMODE: flatbuffers::VOffsetT = 12;
  pub const VT_AUTHFACTOR1_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_AUTHFACTOR1: flatbuffers::VOffsetT = 16;
  pub const VT_AUTHFACTOR2_TYPE: flatbuffers::VOffsetT = 18;
  pub const VT_AUTHFACTOR2: flatbuffers::VOffsetT = 20;
  pub const VT_AUTHFACTOR3_TYPE: flatbuffers::VOffsetT = 22;
  pub const VT_AUTHFACTOR3: flatbuffers::VOffsetT = 24;
  pub const VT_RESUMABLE: flatbuffers::VOffsetT = 26;
  pub const VT_RESUME_SESSION: flatbuffers::VOffsetT = 28;
  pub const VT_RESUME_TOKEN: flatbuffers::VOffsetT = 30;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HelloNew { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args HelloNewArgs<'args>
  ) -> flatbuffers::WIPOffset<HelloNew<'bldr>> {
    let mut builder = HelloNewBuilder::new(_fbb);
    builder.add_resume_session(args.resume_session);
    if let Some(x) = args.resume_token { builder.add_resume_token(x); }
    if let Some(x) = args.authfactor3 { builder.add_authfactor3(x); }
    if let Some(x) = args.authfactor2 { builder.add_authfactor2(x); }
    if let Some(x) = args.authfactor1 { builder.add_authfactor1(x); }
    if let Some(x) = args.authrole { builder.add_authrole(x); }
    if let Some(x) = args.authid { builder.add_authid(x); }
    if let Some(x) = args.realm { builder.add_realm(x); }
    if let Some(x) = args.roles { builder.add_roles(x); }
    builder.add_resumable(args.resumable);
    builder.add_authfactor3_type(args.authfactor3_type);
    builder.add_authfactor2_type(args.authfactor2_type);
    builder.add_authfactor1_type(args.authfactor1_type);
    builder.add_authmode(args.authmode);
    builder.finish()
  }


  #[inline]
  pub fn roles(&self) -> ClientRoles<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<ClientRoles>>(HelloNew::VT_ROLES, None).unwrap()
  }
  #[inline]
  pub fn realm(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HelloNew::VT_REALM, None)
  }
  #[inline]
  pub fn authid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HelloNew::VT_AUTHID, None)
  }
  #[inline]
  pub fn authrole(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HelloNew::VT_AUTHROLE, None)
  }
  #[inline]
  pub fn authmode(&self) -> AuthMode {
    self._tab.get::<AuthMode>(HelloNew::VT_AUTHMODE, Some(AuthMode::FIRST)).unwrap()
  }
  #[inline]
  pub fn authfactor1_type(&self) -> AuthFactor {
    self._tab.get::<AuthFactor>(HelloNew::VT_AUTHFACTOR1_TYPE, Some(AuthFactor::NONE)).unwrap()
  }
  #[inline]
  pub fn authfactor1(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(HelloNew::VT_AUTHFACTOR1, None)
  }
  #[inline]
  pub fn authfactor2_type(&self) -> AuthFactor {
    self._tab.get::<AuthFactor>(HelloNew::VT_AUTHFACTOR2_TYPE, Some(AuthFactor::NONE)).unwrap()
  }
  #[inline]
  pub fn authfactor2(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(HelloNew::VT_AUTHFACTOR2, None)
  }
  #[inline]
  pub fn authfactor3_type(&self) -> AuthFactor {
    self._tab.get::<AuthFactor>(HelloNew::VT_AUTHFACTOR3_TYPE, Some(AuthFactor::NONE)).unwrap()
  }
  #[inline]
  pub fn authfactor3(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(HelloNew::VT_AUTHFACTOR3, None)
  }
  #[inline]
  pub fn resumable(&self) -> bool {
    self._tab.get::<bool>(HelloNew::VT_RESUMABLE, Some(false)).unwrap()
  }
  #[inline]
  pub fn resume_session(&self) -> u64 {
    self._tab.get::<u64>(HelloNew::VT_RESUME_SESSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn resume_token(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(HelloNew::VT_RESUME_TOKEN, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor1_as_auth_ticket_request(&self) -> Option<AuthTicketRequest<'a>> {
    if self.authfactor1_type() == AuthFactor::AuthTicketRequest {
      self.authfactor1().map(AuthTicketRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor1_as_auth_cra_request(&self) -> Option<AuthCraRequest<'a>> {
    if self.authfactor1_type() == AuthFactor::AuthCraRequest {
      self.authfactor1().map(AuthCraRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor1_as_auth_scram_request(&self) -> Option<AuthScramRequest<'a>> {
    if self.authfactor1_type() == AuthFactor::AuthScramRequest {
      self.authfactor1().map(AuthScramRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor1_as_auth_cryptosign_request(&self) -> Option<AuthCryptosignRequest<'a>> {
    if self.authfactor1_type() == AuthFactor::AuthCryptosignRequest {
      self.authfactor1().map(AuthCryptosignRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor2_as_auth_ticket_request(&self) -> Option<AuthTicketRequest<'a>> {
    if self.authfactor2_type() == AuthFactor::AuthTicketRequest {
      self.authfactor2().map(AuthTicketRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor2_as_auth_cra_request(&self) -> Option<AuthCraRequest<'a>> {
    if self.authfactor2_type() == AuthFactor::AuthCraRequest {
      self.authfactor2().map(AuthCraRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor2_as_auth_scram_request(&self) -> Option<AuthScramRequest<'a>> {
    if self.authfactor2_type() == AuthFactor::AuthScramRequest {
      self.authfactor2().map(AuthScramRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor2_as_auth_cryptosign_request(&self) -> Option<AuthCryptosignRequest<'a>> {
    if self.authfactor2_type() == AuthFactor::AuthCryptosignRequest {
      self.authfactor2().map(AuthCryptosignRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor3_as_auth_ticket_request(&self) -> Option<AuthTicketRequest<'a>> {
    if self.authfactor3_type() == AuthFactor::AuthTicketRequest {
      self.authfactor3().map(AuthTicketRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor3_as_auth_cra_request(&self) -> Option<AuthCraRequest<'a>> {
    if self.authfactor3_type() == AuthFactor::AuthCraRequest {
      self.authfactor3().map(AuthCraRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor3_as_auth_scram_request(&self) -> Option<AuthScramRequest<'a>> {
    if self.authfactor3_type() == AuthFactor::AuthScramRequest {
      self.authfactor3().map(AuthScramRequest::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn authfactor3_as_auth_cryptosign_request(&self) -> Option<AuthCryptosignRequest<'a>> {
    if self.authfactor3_type() == AuthFactor::AuthCryptosignRequest {
      self.authfactor3().map(AuthCryptosignRequest::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for HelloNew<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ClientRoles>>("roles", Self::VT_ROLES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("realm", Self::VT_REALM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("authid", Self::VT_AUTHID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("authrole", Self::VT_AUTHROLE, false)?
     .visit_field::<AuthMode>("authmode", Self::VT_AUTHMODE, false)?
     .visit_union::<AuthFactor, _>("authfactor1_type", Self::VT_AUTHFACTOR1_TYPE, "authfactor1", Self::VT_AUTHFACTOR1, false, |key, v, pos| {
        match key {
          AuthFactor::AuthTicketRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthTicketRequest>>("AuthFactor::AuthTicketRequest", pos),
          AuthFactor::AuthCraRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthCraRequest>>("AuthFactor::AuthCraRequest", pos),
          AuthFactor::AuthScramRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthScramRequest>>("AuthFactor::AuthScramRequest", pos),
          AuthFactor::AuthCryptosignRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthCryptosignRequest>>("AuthFactor::AuthCryptosignRequest", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<AuthFactor, _>("authfactor2_type", Self::VT_AUTHFACTOR2_TYPE, "authfactor2", Self::VT_AUTHFACTOR2, false, |key, v, pos| {
        match key {
          AuthFactor::AuthTicketRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthTicketRequest>>("AuthFactor::AuthTicketRequest", pos),
          AuthFactor::AuthCraRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthCraRequest>>("AuthFactor::AuthCraRequest", pos),
          AuthFactor::AuthScramRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthScramRequest>>("AuthFactor::AuthScramRequest", pos),
          AuthFactor::AuthCryptosignRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthCryptosignRequest>>("AuthFactor::AuthCryptosignRequest", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<AuthFactor, _>("authfactor3_type", Self::VT_AUTHFACTOR3_TYPE, "authfactor3", Self::VT_AUTHFACTOR3, false, |key, v, pos| {
        match key {
          AuthFactor::AuthTicketRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthTicketRequest>>("AuthFactor::AuthTicketRequest", pos),
          AuthFactor::AuthCraRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthCraRequest>>("AuthFactor::AuthCraRequest", pos),
          AuthFactor::AuthScramRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthScramRequest>>("AuthFactor::AuthScramRequest", pos),
          AuthFactor::AuthCryptosignRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AuthCryptosignRequest>>("AuthFactor::AuthCryptosignRequest", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<bool>("resumable", Self::VT_RESUMABLE, false)?
     .visit_field::<u64>("resume_session", Self::VT_RESUME_SESSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("resume_token", Self::VT_RESUME_TOKEN, false)?
     .finish();
    Ok(())
  }
}
pub struct HelloNewArgs<'a> {
    pub roles: Option<flatbuffers::WIPOffset<ClientRoles<'a>>>,
    pub realm: Option<flatbuffers::WIPOffset<&'a str>>,
    pub authid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub authrole: Option<flatbuffers::WIPOffset<&'a str>>,
    pub authmode: AuthMode,
    pub authfactor1_type: AuthFactor,
    pub authfactor1: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub authfactor2_type: AuthFactor,
    pub authfactor2: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub authfactor3_type: AuthFactor,
    pub authfactor3: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub resumable: bool,
    pub resume_session: u64,
    pub resume_token: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HelloNewArgs<'a> {
  #[inline]
  fn default() -> Self {
    HelloNewArgs {
      roles: None, // required field
      realm: None,
      authid: None,
      authrole: None,
      authmode: AuthMode::FIRST,
      authfactor1_type: AuthFactor::NONE,
      authfactor1: None,
      authfactor2_type: AuthFactor::NONE,
      authfactor2: None,
      authfactor3_type: AuthFactor::NONE,
      authfactor3: None,
      resumable: false,
      resume_session: 0,
      resume_token: None,
    }
  }
}

pub struct HelloNewBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HelloNewBuilder<'a, 'b> {
  #[inline]
  pub fn add_roles(&mut self, roles: flatbuffers::WIPOffset<ClientRoles<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ClientRoles>>(HelloNew::VT_ROLES, roles);
  }
  #[inline]
  pub fn add_realm(&mut self, realm: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HelloNew::VT_REALM, realm);
  }
  #[inline]
  pub fn add_authid(&mut self, authid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HelloNew::VT_AUTHID, authid);
  }
  #[inline]
  pub fn add_authrole(&mut self, authrole: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HelloNew::VT_AUTHROLE, authrole);
  }
  #[inline]
  pub fn add_authmode(&mut self, authmode: AuthMode) {
    self.fbb_.push_slot::<AuthMode>(HelloNew::VT_AUTHMODE, authmode, AuthMode::FIRST);
  }
  #[inline]
  pub fn add_authfactor1_type(&mut self, authfactor1_type: AuthFactor) {
    self.fbb_.push_slot::<AuthFactor>(HelloNew::VT_AUTHFACTOR1_TYPE, authfactor1_type, AuthFactor::NONE);
  }
  #[inline]
  pub fn add_authfactor1(&mut self, authfactor1: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HelloNew::VT_AUTHFACTOR1, authfactor1);
  }
  #[inline]
  pub fn add_authfactor2_type(&mut self, authfactor2_type: AuthFactor) {
    self.fbb_.push_slot::<AuthFactor>(HelloNew::VT_AUTHFACTOR2_TYPE, authfactor2_type, AuthFactor::NONE);
  }
  #[inline]
  pub fn add_authfactor2(&mut self, authfactor2: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HelloNew::VT_AUTHFACTOR2, authfactor2);
  }
  #[inline]
  pub fn add_authfactor3_type(&mut self, authfactor3_type: AuthFactor) {
    self.fbb_.push_slot::<AuthFactor>(HelloNew::VT_AUTHFACTOR3_TYPE, authfactor3_type, AuthFactor::NONE);
  }
  #[inline]
  pub fn add_authfactor3(&mut self, authfactor3: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HelloNew::VT_AUTHFACTOR3, authfactor3);
  }
  #[inline]
  pub fn add_resumable(&mut self, resumable: bool) {
    self.fbb_.push_slot::<bool>(HelloNew::VT_RESUMABLE, resumable, false);
  }
  #[inline]
  pub fn add_resume_session(&mut self, resume_session: u64) {
    self.fbb_.push_slot::<u64>(HelloNew::VT_RESUME_SESSION, resume_session, 0);
  }
  #[inline]
  pub fn add_resume_token(&mut self, resume_token: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HelloNew::VT_RESUME_TOKEN, resume_token);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HelloNewBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HelloNewBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HelloNew<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, HelloNew::VT_ROLES,"roles");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HelloNew<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HelloNew");
      ds.field("roles", &self.roles());
      ds.field("realm", &self.realm());
      ds.field("authid", &self.authid());
      ds.field("authrole", &self.authrole());
      ds.field("authmode", &self.authmode());
      ds.field("authfactor1_type", &self.authfactor1_type());
      match self.authfactor1_type() {
        AuthFactor::AuthTicketRequest => {
          if let Some(x) = self.authfactor1_as_auth_ticket_request() {
            ds.field("authfactor1", &x)
          } else {
            ds.field("authfactor1", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AuthFactor::AuthCraRequest => {
          if let Some(x) = self.authfactor1_as_auth_cra_request() {
            ds.field("authfactor1", &x)
          } else {
            ds.field("authfactor1", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AuthFactor::AuthScramRequest => {
          if let Some(x) = self.authfactor1_as_auth_scram_request() {
            ds.field("authfactor1", &x)
          } else {
            ds.field("authfactor1", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AuthFactor::AuthCryptosignRequest => {
          if let Some(x) = self.authfactor1_as_auth_cryptosign_request() {
            ds.field("authfactor1", &x)
          } else {
            ds.field("authfactor1", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("authfactor1", &x)
        },
      };
      ds.field("authfactor2_type", &self.authfactor2_type());
      match self.authfactor2_type() {
        AuthFactor::AuthTicketRequest => {
          if let Some(x) = self.authfactor2_as_auth_ticket_request() {
            ds.field("authfactor2", &x)
          } else {
            ds.field("authfactor2", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AuthFactor::AuthCraRequest => {
          if let Some(x) = self.authfactor2_as_auth_cra_request() {
            ds.field("authfactor2", &x)
          } else {
            ds.field("authfactor2", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AuthFactor::AuthScramRequest => {
          if let Some(x) = self.authfactor2_as_auth_scram_request() {
            ds.field("authfactor2", &x)
          } else {
            ds.field("authfactor2", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AuthFactor::AuthCryptosignRequest => {
          if let Some(x) = self.authfactor2_as_auth_cryptosign_request() {
            ds.field("authfactor2", &x)
          } else {
            ds.field("authfactor2", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("authfactor2", &x)
        },
      };
      ds.field("authfactor3_type", &self.authfactor3_type());
      match self.authfactor3_type() {
        AuthFactor::AuthTicketRequest => {
          if let Some(x) = self.authfactor3_as_auth_ticket_request() {
            ds.field("authfactor3", &x)
          } else {
            ds.field("authfactor3", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AuthFactor::AuthCraRequest => {
          if let Some(x) = self.authfactor3_as_auth_cra_request() {
            ds.field("authfactor3", &x)
          } else {
            ds.field("authfactor3", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AuthFactor::AuthScramRequest => {
          if let Some(x) = self.authfactor3_as_auth_scram_request() {
            ds.field("authfactor3", &x)
          } else {
            ds.field("authfactor3", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        AuthFactor::AuthCryptosignRequest => {
          if let Some(x) = self.authfactor3_as_auth_cryptosign_request() {
            ds.field("authfactor3", &x)
          } else {
            ds.field("authfactor3", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("authfactor3", &x)
        },
      };
      ds.field("resumable", &self.resumable());
      ds.field("resume_session", &self.resume_session());
      ds.field("resume_token", &self.resume_token());
      ds.finish()
  }
}
}  // pub mod proto
}  // pub mod wamp

