// automatically generated by the FlatBuffers compiler, do not modify



use crate::types_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod wamp {

  use crate::types_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod proto {

  use crate::types_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum BrokerFeaturesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BrokerFeatures<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BrokerFeatures<'a> {
  type Inner = BrokerFeatures<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BrokerFeatures<'a> {
  pub const VT_PUBLISHER_IDENTIFICATION: flatbuffers::VOffsetT = 4;
  pub const VT_PUBLISHER_EXCLUSION: flatbuffers::VOffsetT = 6;
  pub const VT_SUBSCRIBER_BLACKWHITE_LISTING: flatbuffers::VOffsetT = 8;
  pub const VT_PATTERN_BASED_SUBSCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_PUBLICATION_TRUSTLEVELS: flatbuffers::VOffsetT = 12;
  pub const VT_SUBSCRIPTION_REVOCATION: flatbuffers::VOffsetT = 14;
  pub const VT_SESSION_META_API: flatbuffers::VOffsetT = 16;
  pub const VT_SUBSCRIPTION_META_API: flatbuffers::VOffsetT = 18;
  pub const VT_EVENT_RETENTION: flatbuffers::VOffsetT = 20;
  pub const VT_EVENT_HISTORY: flatbuffers::VOffsetT = 22;
  pub const VT_ACKNOWLEDGE_EVENT_RECEIVED: flatbuffers::VOffsetT = 24;
  pub const VT_ACKNOWLEDGE_SUBSCRIBER_RECEIVED: flatbuffers::VOffsetT = 26;
  pub const VT_PAYLOAD_TRANSPARENCY: flatbuffers::VOffsetT = 28;
  pub const VT_PAYLOAD_ENCRYPTION_CRYPTOBOX: flatbuffers::VOffsetT = 30;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BrokerFeatures { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BrokerFeaturesArgs
  ) -> flatbuffers::WIPOffset<BrokerFeatures<'bldr>> {
    let mut builder = BrokerFeaturesBuilder::new(_fbb);
    builder.add_payload_encryption_cryptobox(args.payload_encryption_cryptobox);
    builder.add_payload_transparency(args.payload_transparency);
    builder.add_acknowledge_subscriber_received(args.acknowledge_subscriber_received);
    builder.add_acknowledge_event_received(args.acknowledge_event_received);
    builder.add_event_history(args.event_history);
    builder.add_event_retention(args.event_retention);
    builder.add_subscription_meta_api(args.subscription_meta_api);
    builder.add_session_meta_api(args.session_meta_api);
    builder.add_subscription_revocation(args.subscription_revocation);
    builder.add_publication_trustlevels(args.publication_trustlevels);
    builder.add_pattern_based_subscription(args.pattern_based_subscription);
    builder.add_subscriber_blackwhite_listing(args.subscriber_blackwhite_listing);
    builder.add_publisher_exclusion(args.publisher_exclusion);
    builder.add_publisher_identification(args.publisher_identification);
    builder.finish()
  }


  #[inline]
  pub fn publisher_identification(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_PUBLISHER_IDENTIFICATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn publisher_exclusion(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_PUBLISHER_EXCLUSION, Some(false)).unwrap()
  }
  #[inline]
  pub fn subscriber_blackwhite_listing(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_SUBSCRIBER_BLACKWHITE_LISTING, Some(false)).unwrap()
  }
  #[inline]
  pub fn pattern_based_subscription(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_PATTERN_BASED_SUBSCRIPTION, Some(false)).unwrap()
  }
  #[inline]
  pub fn publication_trustlevels(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_PUBLICATION_TRUSTLEVELS, Some(false)).unwrap()
  }
  #[inline]
  pub fn subscription_revocation(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_SUBSCRIPTION_REVOCATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn session_meta_api(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_SESSION_META_API, Some(false)).unwrap()
  }
  #[inline]
  pub fn subscription_meta_api(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_SUBSCRIPTION_META_API, Some(false)).unwrap()
  }
  #[inline]
  pub fn event_retention(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_EVENT_RETENTION, Some(false)).unwrap()
  }
  #[inline]
  pub fn event_history(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_EVENT_HISTORY, Some(false)).unwrap()
  }
  #[inline]
  pub fn acknowledge_event_received(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_ACKNOWLEDGE_EVENT_RECEIVED, Some(false)).unwrap()
  }
  #[inline]
  pub fn acknowledge_subscriber_received(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_ACKNOWLEDGE_SUBSCRIBER_RECEIVED, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_transparency(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_PAYLOAD_TRANSPARENCY, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_encryption_cryptobox(&self) -> bool {
    self._tab.get::<bool>(BrokerFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for BrokerFeatures<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("publisher_identification", Self::VT_PUBLISHER_IDENTIFICATION, false)?
     .visit_field::<bool>("publisher_exclusion", Self::VT_PUBLISHER_EXCLUSION, false)?
     .visit_field::<bool>("subscriber_blackwhite_listing", Self::VT_SUBSCRIBER_BLACKWHITE_LISTING, false)?
     .visit_field::<bool>("pattern_based_subscription", Self::VT_PATTERN_BASED_SUBSCRIPTION, false)?
     .visit_field::<bool>("publication_trustlevels", Self::VT_PUBLICATION_TRUSTLEVELS, false)?
     .visit_field::<bool>("subscription_revocation", Self::VT_SUBSCRIPTION_REVOCATION, false)?
     .visit_field::<bool>("session_meta_api", Self::VT_SESSION_META_API, false)?
     .visit_field::<bool>("subscription_meta_api", Self::VT_SUBSCRIPTION_META_API, false)?
     .visit_field::<bool>("event_retention", Self::VT_EVENT_RETENTION, false)?
     .visit_field::<bool>("event_history", Self::VT_EVENT_HISTORY, false)?
     .visit_field::<bool>("acknowledge_event_received", Self::VT_ACKNOWLEDGE_EVENT_RECEIVED, false)?
     .visit_field::<bool>("acknowledge_subscriber_received", Self::VT_ACKNOWLEDGE_SUBSCRIBER_RECEIVED, false)?
     .visit_field::<bool>("payload_transparency", Self::VT_PAYLOAD_TRANSPARENCY, false)?
     .visit_field::<bool>("payload_encryption_cryptobox", Self::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, false)?
     .finish();
    Ok(())
  }
}
pub struct BrokerFeaturesArgs {
    pub publisher_identification: bool,
    pub publisher_exclusion: bool,
    pub subscriber_blackwhite_listing: bool,
    pub pattern_based_subscription: bool,
    pub publication_trustlevels: bool,
    pub subscription_revocation: bool,
    pub session_meta_api: bool,
    pub subscription_meta_api: bool,
    pub event_retention: bool,
    pub event_history: bool,
    pub acknowledge_event_received: bool,
    pub acknowledge_subscriber_received: bool,
    pub payload_transparency: bool,
    pub payload_encryption_cryptobox: bool,
}
impl<'a> Default for BrokerFeaturesArgs {
  #[inline]
  fn default() -> Self {
    BrokerFeaturesArgs {
      publisher_identification: false,
      publisher_exclusion: false,
      subscriber_blackwhite_listing: false,
      pattern_based_subscription: false,
      publication_trustlevels: false,
      subscription_revocation: false,
      session_meta_api: false,
      subscription_meta_api: false,
      event_retention: false,
      event_history: false,
      acknowledge_event_received: false,
      acknowledge_subscriber_received: false,
      payload_transparency: false,
      payload_encryption_cryptobox: false,
    }
  }
}

pub struct BrokerFeaturesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BrokerFeaturesBuilder<'a, 'b> {
  #[inline]
  pub fn add_publisher_identification(&mut self, publisher_identification: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_PUBLISHER_IDENTIFICATION, publisher_identification, false);
  }
  #[inline]
  pub fn add_publisher_exclusion(&mut self, publisher_exclusion: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_PUBLISHER_EXCLUSION, publisher_exclusion, false);
  }
  #[inline]
  pub fn add_subscriber_blackwhite_listing(&mut self, subscriber_blackwhite_listing: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_SUBSCRIBER_BLACKWHITE_LISTING, subscriber_blackwhite_listing, false);
  }
  #[inline]
  pub fn add_pattern_based_subscription(&mut self, pattern_based_subscription: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_PATTERN_BASED_SUBSCRIPTION, pattern_based_subscription, false);
  }
  #[inline]
  pub fn add_publication_trustlevels(&mut self, publication_trustlevels: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_PUBLICATION_TRUSTLEVELS, publication_trustlevels, false);
  }
  #[inline]
  pub fn add_subscription_revocation(&mut self, subscription_revocation: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_SUBSCRIPTION_REVOCATION, subscription_revocation, false);
  }
  #[inline]
  pub fn add_session_meta_api(&mut self, session_meta_api: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_SESSION_META_API, session_meta_api, false);
  }
  #[inline]
  pub fn add_subscription_meta_api(&mut self, subscription_meta_api: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_SUBSCRIPTION_META_API, subscription_meta_api, false);
  }
  #[inline]
  pub fn add_event_retention(&mut self, event_retention: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_EVENT_RETENTION, event_retention, false);
  }
  #[inline]
  pub fn add_event_history(&mut self, event_history: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_EVENT_HISTORY, event_history, false);
  }
  #[inline]
  pub fn add_acknowledge_event_received(&mut self, acknowledge_event_received: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_ACKNOWLEDGE_EVENT_RECEIVED, acknowledge_event_received, false);
  }
  #[inline]
  pub fn add_acknowledge_subscriber_received(&mut self, acknowledge_subscriber_received: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_ACKNOWLEDGE_SUBSCRIBER_RECEIVED, acknowledge_subscriber_received, false);
  }
  #[inline]
  pub fn add_payload_transparency(&mut self, payload_transparency: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_PAYLOAD_TRANSPARENCY, payload_transparency, false);
  }
  #[inline]
  pub fn add_payload_encryption_cryptobox(&mut self, payload_encryption_cryptobox: bool) {
    self.fbb_.push_slot::<bool>(BrokerFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, payload_encryption_cryptobox, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BrokerFeaturesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BrokerFeaturesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BrokerFeatures<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BrokerFeatures<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BrokerFeatures");
      ds.field("publisher_identification", &self.publisher_identification());
      ds.field("publisher_exclusion", &self.publisher_exclusion());
      ds.field("subscriber_blackwhite_listing", &self.subscriber_blackwhite_listing());
      ds.field("pattern_based_subscription", &self.pattern_based_subscription());
      ds.field("publication_trustlevels", &self.publication_trustlevels());
      ds.field("subscription_revocation", &self.subscription_revocation());
      ds.field("session_meta_api", &self.session_meta_api());
      ds.field("subscription_meta_api", &self.subscription_meta_api());
      ds.field("event_retention", &self.event_retention());
      ds.field("event_history", &self.event_history());
      ds.field("acknowledge_event_received", &self.acknowledge_event_received());
      ds.field("acknowledge_subscriber_received", &self.acknowledge_subscriber_received());
      ds.field("payload_transparency", &self.payload_transparency());
      ds.field("payload_encryption_cryptobox", &self.payload_encryption_cryptobox());
      ds.finish()
  }
}
pub enum PublisherFeaturesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PublisherFeatures<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PublisherFeatures<'a> {
  type Inner = PublisherFeatures<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PublisherFeatures<'a> {
  pub const VT_PUBLISHER_IDENTIFICATION: flatbuffers::VOffsetT = 4;
  pub const VT_PUBLISHER_EXCLUSION: flatbuffers::VOffsetT = 6;
  pub const VT_SUBSCRIBER_BLACKWHITE_LISTING: flatbuffers::VOffsetT = 8;
  pub const VT_ACKNOWLEDGE_EVENT_RECEIVED: flatbuffers::VOffsetT = 10;
  pub const VT_PAYLOAD_TRANSPARENCY: flatbuffers::VOffsetT = 12;
  pub const VT_PAYLOAD_ENCRYPTION_CRYPTOBOX: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PublisherFeatures { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PublisherFeaturesArgs
  ) -> flatbuffers::WIPOffset<PublisherFeatures<'bldr>> {
    let mut builder = PublisherFeaturesBuilder::new(_fbb);
    builder.add_payload_encryption_cryptobox(args.payload_encryption_cryptobox);
    builder.add_payload_transparency(args.payload_transparency);
    builder.add_acknowledge_event_received(args.acknowledge_event_received);
    builder.add_subscriber_blackwhite_listing(args.subscriber_blackwhite_listing);
    builder.add_publisher_exclusion(args.publisher_exclusion);
    builder.add_publisher_identification(args.publisher_identification);
    builder.finish()
  }


  #[inline]
  pub fn publisher_identification(&self) -> bool {
    self._tab.get::<bool>(PublisherFeatures::VT_PUBLISHER_IDENTIFICATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn publisher_exclusion(&self) -> bool {
    self._tab.get::<bool>(PublisherFeatures::VT_PUBLISHER_EXCLUSION, Some(false)).unwrap()
  }
  #[inline]
  pub fn subscriber_blackwhite_listing(&self) -> bool {
    self._tab.get::<bool>(PublisherFeatures::VT_SUBSCRIBER_BLACKWHITE_LISTING, Some(false)).unwrap()
  }
  #[inline]
  pub fn acknowledge_event_received(&self) -> bool {
    self._tab.get::<bool>(PublisherFeatures::VT_ACKNOWLEDGE_EVENT_RECEIVED, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_transparency(&self) -> bool {
    self._tab.get::<bool>(PublisherFeatures::VT_PAYLOAD_TRANSPARENCY, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_encryption_cryptobox(&self) -> bool {
    self._tab.get::<bool>(PublisherFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for PublisherFeatures<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("publisher_identification", Self::VT_PUBLISHER_IDENTIFICATION, false)?
     .visit_field::<bool>("publisher_exclusion", Self::VT_PUBLISHER_EXCLUSION, false)?
     .visit_field::<bool>("subscriber_blackwhite_listing", Self::VT_SUBSCRIBER_BLACKWHITE_LISTING, false)?
     .visit_field::<bool>("acknowledge_event_received", Self::VT_ACKNOWLEDGE_EVENT_RECEIVED, false)?
     .visit_field::<bool>("payload_transparency", Self::VT_PAYLOAD_TRANSPARENCY, false)?
     .visit_field::<bool>("payload_encryption_cryptobox", Self::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, false)?
     .finish();
    Ok(())
  }
}
pub struct PublisherFeaturesArgs {
    pub publisher_identification: bool,
    pub publisher_exclusion: bool,
    pub subscriber_blackwhite_listing: bool,
    pub acknowledge_event_received: bool,
    pub payload_transparency: bool,
    pub payload_encryption_cryptobox: bool,
}
impl<'a> Default for PublisherFeaturesArgs {
  #[inline]
  fn default() -> Self {
    PublisherFeaturesArgs {
      publisher_identification: false,
      publisher_exclusion: false,
      subscriber_blackwhite_listing: false,
      acknowledge_event_received: false,
      payload_transparency: false,
      payload_encryption_cryptobox: false,
    }
  }
}

pub struct PublisherFeaturesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PublisherFeaturesBuilder<'a, 'b> {
  #[inline]
  pub fn add_publisher_identification(&mut self, publisher_identification: bool) {
    self.fbb_.push_slot::<bool>(PublisherFeatures::VT_PUBLISHER_IDENTIFICATION, publisher_identification, false);
  }
  #[inline]
  pub fn add_publisher_exclusion(&mut self, publisher_exclusion: bool) {
    self.fbb_.push_slot::<bool>(PublisherFeatures::VT_PUBLISHER_EXCLUSION, publisher_exclusion, false);
  }
  #[inline]
  pub fn add_subscriber_blackwhite_listing(&mut self, subscriber_blackwhite_listing: bool) {
    self.fbb_.push_slot::<bool>(PublisherFeatures::VT_SUBSCRIBER_BLACKWHITE_LISTING, subscriber_blackwhite_listing, false);
  }
  #[inline]
  pub fn add_acknowledge_event_received(&mut self, acknowledge_event_received: bool) {
    self.fbb_.push_slot::<bool>(PublisherFeatures::VT_ACKNOWLEDGE_EVENT_RECEIVED, acknowledge_event_received, false);
  }
  #[inline]
  pub fn add_payload_transparency(&mut self, payload_transparency: bool) {
    self.fbb_.push_slot::<bool>(PublisherFeatures::VT_PAYLOAD_TRANSPARENCY, payload_transparency, false);
  }
  #[inline]
  pub fn add_payload_encryption_cryptobox(&mut self, payload_encryption_cryptobox: bool) {
    self.fbb_.push_slot::<bool>(PublisherFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, payload_encryption_cryptobox, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PublisherFeaturesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PublisherFeaturesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PublisherFeatures<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PublisherFeatures<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PublisherFeatures");
      ds.field("publisher_identification", &self.publisher_identification());
      ds.field("publisher_exclusion", &self.publisher_exclusion());
      ds.field("subscriber_blackwhite_listing", &self.subscriber_blackwhite_listing());
      ds.field("acknowledge_event_received", &self.acknowledge_event_received());
      ds.field("payload_transparency", &self.payload_transparency());
      ds.field("payload_encryption_cryptobox", &self.payload_encryption_cryptobox());
      ds.finish()
  }
}
pub enum SubscriberFeaturesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubscriberFeatures<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubscriberFeatures<'a> {
  type Inner = SubscriberFeatures<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SubscriberFeatures<'a> {
  pub const VT_PUBLISHER_IDENTIFICATION: flatbuffers::VOffsetT = 4;
  pub const VT_PATTERN_BASED_SUBSCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_PUBLICATION_TRUSTLEVELS: flatbuffers::VOffsetT = 8;
  pub const VT_SUBSCRIPTION_REVOCATION: flatbuffers::VOffsetT = 10;
  pub const VT_EVENT_HISTORY: flatbuffers::VOffsetT = 12;
  pub const VT_ACKNOWLEDGE_SUBSCRIBER_RECEIVED: flatbuffers::VOffsetT = 14;
  pub const VT_PAYLOAD_TRANSPARENCY: flatbuffers::VOffsetT = 16;
  pub const VT_PAYLOAD_ENCRYPTION_CRYPTOBOX: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubscriberFeatures { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubscriberFeaturesArgs
  ) -> flatbuffers::WIPOffset<SubscriberFeatures<'bldr>> {
    let mut builder = SubscriberFeaturesBuilder::new(_fbb);
    builder.add_payload_encryption_cryptobox(args.payload_encryption_cryptobox);
    builder.add_payload_transparency(args.payload_transparency);
    builder.add_acknowledge_subscriber_received(args.acknowledge_subscriber_received);
    builder.add_event_history(args.event_history);
    builder.add_subscription_revocation(args.subscription_revocation);
    builder.add_publication_trustlevels(args.publication_trustlevels);
    builder.add_pattern_based_subscription(args.pattern_based_subscription);
    builder.add_publisher_identification(args.publisher_identification);
    builder.finish()
  }


  #[inline]
  pub fn publisher_identification(&self) -> bool {
    self._tab.get::<bool>(SubscriberFeatures::VT_PUBLISHER_IDENTIFICATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn pattern_based_subscription(&self) -> bool {
    self._tab.get::<bool>(SubscriberFeatures::VT_PATTERN_BASED_SUBSCRIPTION, Some(false)).unwrap()
  }
  #[inline]
  pub fn publication_trustlevels(&self) -> bool {
    self._tab.get::<bool>(SubscriberFeatures::VT_PUBLICATION_TRUSTLEVELS, Some(false)).unwrap()
  }
  #[inline]
  pub fn subscription_revocation(&self) -> bool {
    self._tab.get::<bool>(SubscriberFeatures::VT_SUBSCRIPTION_REVOCATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn event_history(&self) -> bool {
    self._tab.get::<bool>(SubscriberFeatures::VT_EVENT_HISTORY, Some(false)).unwrap()
  }
  #[inline]
  pub fn acknowledge_subscriber_received(&self) -> bool {
    self._tab.get::<bool>(SubscriberFeatures::VT_ACKNOWLEDGE_SUBSCRIBER_RECEIVED, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_transparency(&self) -> bool {
    self._tab.get::<bool>(SubscriberFeatures::VT_PAYLOAD_TRANSPARENCY, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_encryption_cryptobox(&self) -> bool {
    self._tab.get::<bool>(SubscriberFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for SubscriberFeatures<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("publisher_identification", Self::VT_PUBLISHER_IDENTIFICATION, false)?
     .visit_field::<bool>("pattern_based_subscription", Self::VT_PATTERN_BASED_SUBSCRIPTION, false)?
     .visit_field::<bool>("publication_trustlevels", Self::VT_PUBLICATION_TRUSTLEVELS, false)?
     .visit_field::<bool>("subscription_revocation", Self::VT_SUBSCRIPTION_REVOCATION, false)?
     .visit_field::<bool>("event_history", Self::VT_EVENT_HISTORY, false)?
     .visit_field::<bool>("acknowledge_subscriber_received", Self::VT_ACKNOWLEDGE_SUBSCRIBER_RECEIVED, false)?
     .visit_field::<bool>("payload_transparency", Self::VT_PAYLOAD_TRANSPARENCY, false)?
     .visit_field::<bool>("payload_encryption_cryptobox", Self::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, false)?
     .finish();
    Ok(())
  }
}
pub struct SubscriberFeaturesArgs {
    pub publisher_identification: bool,
    pub pattern_based_subscription: bool,
    pub publication_trustlevels: bool,
    pub subscription_revocation: bool,
    pub event_history: bool,
    pub acknowledge_subscriber_received: bool,
    pub payload_transparency: bool,
    pub payload_encryption_cryptobox: bool,
}
impl<'a> Default for SubscriberFeaturesArgs {
  #[inline]
  fn default() -> Self {
    SubscriberFeaturesArgs {
      publisher_identification: false,
      pattern_based_subscription: false,
      publication_trustlevels: false,
      subscription_revocation: false,
      event_history: false,
      acknowledge_subscriber_received: false,
      payload_transparency: false,
      payload_encryption_cryptobox: false,
    }
  }
}

pub struct SubscriberFeaturesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubscriberFeaturesBuilder<'a, 'b> {
  #[inline]
  pub fn add_publisher_identification(&mut self, publisher_identification: bool) {
    self.fbb_.push_slot::<bool>(SubscriberFeatures::VT_PUBLISHER_IDENTIFICATION, publisher_identification, false);
  }
  #[inline]
  pub fn add_pattern_based_subscription(&mut self, pattern_based_subscription: bool) {
    self.fbb_.push_slot::<bool>(SubscriberFeatures::VT_PATTERN_BASED_SUBSCRIPTION, pattern_based_subscription, false);
  }
  #[inline]
  pub fn add_publication_trustlevels(&mut self, publication_trustlevels: bool) {
    self.fbb_.push_slot::<bool>(SubscriberFeatures::VT_PUBLICATION_TRUSTLEVELS, publication_trustlevels, false);
  }
  #[inline]
  pub fn add_subscription_revocation(&mut self, subscription_revocation: bool) {
    self.fbb_.push_slot::<bool>(SubscriberFeatures::VT_SUBSCRIPTION_REVOCATION, subscription_revocation, false);
  }
  #[inline]
  pub fn add_event_history(&mut self, event_history: bool) {
    self.fbb_.push_slot::<bool>(SubscriberFeatures::VT_EVENT_HISTORY, event_history, false);
  }
  #[inline]
  pub fn add_acknowledge_subscriber_received(&mut self, acknowledge_subscriber_received: bool) {
    self.fbb_.push_slot::<bool>(SubscriberFeatures::VT_ACKNOWLEDGE_SUBSCRIBER_RECEIVED, acknowledge_subscriber_received, false);
  }
  #[inline]
  pub fn add_payload_transparency(&mut self, payload_transparency: bool) {
    self.fbb_.push_slot::<bool>(SubscriberFeatures::VT_PAYLOAD_TRANSPARENCY, payload_transparency, false);
  }
  #[inline]
  pub fn add_payload_encryption_cryptobox(&mut self, payload_encryption_cryptobox: bool) {
    self.fbb_.push_slot::<bool>(SubscriberFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, payload_encryption_cryptobox, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubscriberFeaturesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubscriberFeaturesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubscriberFeatures<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubscriberFeatures<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubscriberFeatures");
      ds.field("publisher_identification", &self.publisher_identification());
      ds.field("pattern_based_subscription", &self.pattern_based_subscription());
      ds.field("publication_trustlevels", &self.publication_trustlevels());
      ds.field("subscription_revocation", &self.subscription_revocation());
      ds.field("event_history", &self.event_history());
      ds.field("acknowledge_subscriber_received", &self.acknowledge_subscriber_received());
      ds.field("payload_transparency", &self.payload_transparency());
      ds.field("payload_encryption_cryptobox", &self.payload_encryption_cryptobox());
      ds.finish()
  }
}
pub enum DealerFeaturesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DealerFeatures<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DealerFeatures<'a> {
  type Inner = DealerFeatures<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> DealerFeatures<'a> {
  pub const VT_CALLER_IDENTIFICATION: flatbuffers::VOffsetT = 4;
  pub const VT_CALL_TRUSTLEVELS: flatbuffers::VOffsetT = 6;
  pub const VT_CALL_TIMEOUT: flatbuffers::VOffsetT = 8;
  pub const VT_CALL_CANCELING: flatbuffers::VOffsetT = 10;
  pub const VT_PROGRESSIVE_CALL_RESULTS: flatbuffers::VOffsetT = 12;
  pub const VT_REGISTRATION_REVOCATION: flatbuffers::VOffsetT = 14;
  pub const VT_PATTERN_BASED_REGISTRATION: flatbuffers::VOffsetT = 16;
  pub const VT_SHARED_REGISTRATION: flatbuffers::VOffsetT = 18;
  pub const VT_SESSION_META_API: flatbuffers::VOffsetT = 20;
  pub const VT_REGISTRATION_META_API: flatbuffers::VOffsetT = 22;
  pub const VT_TESTAMENT_META_API: flatbuffers::VOffsetT = 24;
  pub const VT_PAYLOAD_TRANSPARENCY: flatbuffers::VOffsetT = 26;
  pub const VT_PAYLOAD_ENCRYPTION_CRYPTOBOX: flatbuffers::VOffsetT = 28;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DealerFeatures { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DealerFeaturesArgs
  ) -> flatbuffers::WIPOffset<DealerFeatures<'bldr>> {
    let mut builder = DealerFeaturesBuilder::new(_fbb);
    builder.add_payload_encryption_cryptobox(args.payload_encryption_cryptobox);
    builder.add_payload_transparency(args.payload_transparency);
    builder.add_testament_meta_api(args.testament_meta_api);
    builder.add_registration_meta_api(args.registration_meta_api);
    builder.add_session_meta_api(args.session_meta_api);
    builder.add_shared_registration(args.shared_registration);
    builder.add_pattern_based_registration(args.pattern_based_registration);
    builder.add_registration_revocation(args.registration_revocation);
    builder.add_progressive_call_results(args.progressive_call_results);
    builder.add_call_canceling(args.call_canceling);
    builder.add_call_timeout(args.call_timeout);
    builder.add_call_trustlevels(args.call_trustlevels);
    builder.add_caller_identification(args.caller_identification);
    builder.finish()
  }


  #[inline]
  pub fn caller_identification(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_CALLER_IDENTIFICATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn call_trustlevels(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_CALL_TRUSTLEVELS, Some(false)).unwrap()
  }
  #[inline]
  pub fn call_timeout(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_CALL_TIMEOUT, Some(false)).unwrap()
  }
  #[inline]
  pub fn call_canceling(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_CALL_CANCELING, Some(false)).unwrap()
  }
  #[inline]
  pub fn progressive_call_results(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_PROGRESSIVE_CALL_RESULTS, Some(false)).unwrap()
  }
  #[inline]
  pub fn registration_revocation(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_REGISTRATION_REVOCATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn pattern_based_registration(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_PATTERN_BASED_REGISTRATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn shared_registration(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_SHARED_REGISTRATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn session_meta_api(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_SESSION_META_API, Some(false)).unwrap()
  }
  #[inline]
  pub fn registration_meta_api(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_REGISTRATION_META_API, Some(false)).unwrap()
  }
  #[inline]
  pub fn testament_meta_api(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_TESTAMENT_META_API, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_transparency(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_PAYLOAD_TRANSPARENCY, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_encryption_cryptobox(&self) -> bool {
    self._tab.get::<bool>(DealerFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for DealerFeatures<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("caller_identification", Self::VT_CALLER_IDENTIFICATION, false)?
     .visit_field::<bool>("call_trustlevels", Self::VT_CALL_TRUSTLEVELS, false)?
     .visit_field::<bool>("call_timeout", Self::VT_CALL_TIMEOUT, false)?
     .visit_field::<bool>("call_canceling", Self::VT_CALL_CANCELING, false)?
     .visit_field::<bool>("progressive_call_results", Self::VT_PROGRESSIVE_CALL_RESULTS, false)?
     .visit_field::<bool>("registration_revocation", Self::VT_REGISTRATION_REVOCATION, false)?
     .visit_field::<bool>("pattern_based_registration", Self::VT_PATTERN_BASED_REGISTRATION, false)?
     .visit_field::<bool>("shared_registration", Self::VT_SHARED_REGISTRATION, false)?
     .visit_field::<bool>("session_meta_api", Self::VT_SESSION_META_API, false)?
     .visit_field::<bool>("registration_meta_api", Self::VT_REGISTRATION_META_API, false)?
     .visit_field::<bool>("testament_meta_api", Self::VT_TESTAMENT_META_API, false)?
     .visit_field::<bool>("payload_transparency", Self::VT_PAYLOAD_TRANSPARENCY, false)?
     .visit_field::<bool>("payload_encryption_cryptobox", Self::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, false)?
     .finish();
    Ok(())
  }
}
pub struct DealerFeaturesArgs {
    pub caller_identification: bool,
    pub call_trustlevels: bool,
    pub call_timeout: bool,
    pub call_canceling: bool,
    pub progressive_call_results: bool,
    pub registration_revocation: bool,
    pub pattern_based_registration: bool,
    pub shared_registration: bool,
    pub session_meta_api: bool,
    pub registration_meta_api: bool,
    pub testament_meta_api: bool,
    pub payload_transparency: bool,
    pub payload_encryption_cryptobox: bool,
}
impl<'a> Default for DealerFeaturesArgs {
  #[inline]
  fn default() -> Self {
    DealerFeaturesArgs {
      caller_identification: false,
      call_trustlevels: false,
      call_timeout: false,
      call_canceling: false,
      progressive_call_results: false,
      registration_revocation: false,
      pattern_based_registration: false,
      shared_registration: false,
      session_meta_api: false,
      registration_meta_api: false,
      testament_meta_api: false,
      payload_transparency: false,
      payload_encryption_cryptobox: false,
    }
  }
}

pub struct DealerFeaturesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DealerFeaturesBuilder<'a, 'b> {
  #[inline]
  pub fn add_caller_identification(&mut self, caller_identification: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_CALLER_IDENTIFICATION, caller_identification, false);
  }
  #[inline]
  pub fn add_call_trustlevels(&mut self, call_trustlevels: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_CALL_TRUSTLEVELS, call_trustlevels, false);
  }
  #[inline]
  pub fn add_call_timeout(&mut self, call_timeout: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_CALL_TIMEOUT, call_timeout, false);
  }
  #[inline]
  pub fn add_call_canceling(&mut self, call_canceling: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_CALL_CANCELING, call_canceling, false);
  }
  #[inline]
  pub fn add_progressive_call_results(&mut self, progressive_call_results: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_PROGRESSIVE_CALL_RESULTS, progressive_call_results, false);
  }
  #[inline]
  pub fn add_registration_revocation(&mut self, registration_revocation: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_REGISTRATION_REVOCATION, registration_revocation, false);
  }
  #[inline]
  pub fn add_pattern_based_registration(&mut self, pattern_based_registration: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_PATTERN_BASED_REGISTRATION, pattern_based_registration, false);
  }
  #[inline]
  pub fn add_shared_registration(&mut self, shared_registration: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_SHARED_REGISTRATION, shared_registration, false);
  }
  #[inline]
  pub fn add_session_meta_api(&mut self, session_meta_api: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_SESSION_META_API, session_meta_api, false);
  }
  #[inline]
  pub fn add_registration_meta_api(&mut self, registration_meta_api: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_REGISTRATION_META_API, registration_meta_api, false);
  }
  #[inline]
  pub fn add_testament_meta_api(&mut self, testament_meta_api: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_TESTAMENT_META_API, testament_meta_api, false);
  }
  #[inline]
  pub fn add_payload_transparency(&mut self, payload_transparency: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_PAYLOAD_TRANSPARENCY, payload_transparency, false);
  }
  #[inline]
  pub fn add_payload_encryption_cryptobox(&mut self, payload_encryption_cryptobox: bool) {
    self.fbb_.push_slot::<bool>(DealerFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, payload_encryption_cryptobox, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DealerFeaturesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DealerFeaturesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DealerFeatures<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DealerFeatures<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DealerFeatures");
      ds.field("caller_identification", &self.caller_identification());
      ds.field("call_trustlevels", &self.call_trustlevels());
      ds.field("call_timeout", &self.call_timeout());
      ds.field("call_canceling", &self.call_canceling());
      ds.field("progressive_call_results", &self.progressive_call_results());
      ds.field("registration_revocation", &self.registration_revocation());
      ds.field("pattern_based_registration", &self.pattern_based_registration());
      ds.field("shared_registration", &self.shared_registration());
      ds.field("session_meta_api", &self.session_meta_api());
      ds.field("registration_meta_api", &self.registration_meta_api());
      ds.field("testament_meta_api", &self.testament_meta_api());
      ds.field("payload_transparency", &self.payload_transparency());
      ds.field("payload_encryption_cryptobox", &self.payload_encryption_cryptobox());
      ds.finish()
  }
}
pub enum CallerFeaturesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CallerFeatures<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CallerFeatures<'a> {
  type Inner = CallerFeatures<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> CallerFeatures<'a> {
  pub const VT_CALLER_IDENTIFICATION: flatbuffers::VOffsetT = 4;
  pub const VT_CALL_TIMEOUT: flatbuffers::VOffsetT = 6;
  pub const VT_CALL_CANCELING: flatbuffers::VOffsetT = 8;
  pub const VT_PROGRESSIVE_CALL_RESULTS: flatbuffers::VOffsetT = 10;
  pub const VT_PAYLOAD_TRANSPARENCY: flatbuffers::VOffsetT = 12;
  pub const VT_PAYLOAD_ENCRYPTION_CRYPTOBOX: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CallerFeatures { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CallerFeaturesArgs
  ) -> flatbuffers::WIPOffset<CallerFeatures<'bldr>> {
    let mut builder = CallerFeaturesBuilder::new(_fbb);
    builder.add_payload_encryption_cryptobox(args.payload_encryption_cryptobox);
    builder.add_payload_transparency(args.payload_transparency);
    builder.add_progressive_call_results(args.progressive_call_results);
    builder.add_call_canceling(args.call_canceling);
    builder.add_call_timeout(args.call_timeout);
    builder.add_caller_identification(args.caller_identification);
    builder.finish()
  }


  #[inline]
  pub fn caller_identification(&self) -> bool {
    self._tab.get::<bool>(CallerFeatures::VT_CALLER_IDENTIFICATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn call_timeout(&self) -> bool {
    self._tab.get::<bool>(CallerFeatures::VT_CALL_TIMEOUT, Some(false)).unwrap()
  }
  #[inline]
  pub fn call_canceling(&self) -> bool {
    self._tab.get::<bool>(CallerFeatures::VT_CALL_CANCELING, Some(false)).unwrap()
  }
  #[inline]
  pub fn progressive_call_results(&self) -> bool {
    self._tab.get::<bool>(CallerFeatures::VT_PROGRESSIVE_CALL_RESULTS, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_transparency(&self) -> bool {
    self._tab.get::<bool>(CallerFeatures::VT_PAYLOAD_TRANSPARENCY, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_encryption_cryptobox(&self) -> bool {
    self._tab.get::<bool>(CallerFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for CallerFeatures<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("caller_identification", Self::VT_CALLER_IDENTIFICATION, false)?
     .visit_field::<bool>("call_timeout", Self::VT_CALL_TIMEOUT, false)?
     .visit_field::<bool>("call_canceling", Self::VT_CALL_CANCELING, false)?
     .visit_field::<bool>("progressive_call_results", Self::VT_PROGRESSIVE_CALL_RESULTS, false)?
     .visit_field::<bool>("payload_transparency", Self::VT_PAYLOAD_TRANSPARENCY, false)?
     .visit_field::<bool>("payload_encryption_cryptobox", Self::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, false)?
     .finish();
    Ok(())
  }
}
pub struct CallerFeaturesArgs {
    pub caller_identification: bool,
    pub call_timeout: bool,
    pub call_canceling: bool,
    pub progressive_call_results: bool,
    pub payload_transparency: bool,
    pub payload_encryption_cryptobox: bool,
}
impl<'a> Default for CallerFeaturesArgs {
  #[inline]
  fn default() -> Self {
    CallerFeaturesArgs {
      caller_identification: false,
      call_timeout: false,
      call_canceling: false,
      progressive_call_results: false,
      payload_transparency: false,
      payload_encryption_cryptobox: false,
    }
  }
}

pub struct CallerFeaturesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CallerFeaturesBuilder<'a, 'b> {
  #[inline]
  pub fn add_caller_identification(&mut self, caller_identification: bool) {
    self.fbb_.push_slot::<bool>(CallerFeatures::VT_CALLER_IDENTIFICATION, caller_identification, false);
  }
  #[inline]
  pub fn add_call_timeout(&mut self, call_timeout: bool) {
    self.fbb_.push_slot::<bool>(CallerFeatures::VT_CALL_TIMEOUT, call_timeout, false);
  }
  #[inline]
  pub fn add_call_canceling(&mut self, call_canceling: bool) {
    self.fbb_.push_slot::<bool>(CallerFeatures::VT_CALL_CANCELING, call_canceling, false);
  }
  #[inline]
  pub fn add_progressive_call_results(&mut self, progressive_call_results: bool) {
    self.fbb_.push_slot::<bool>(CallerFeatures::VT_PROGRESSIVE_CALL_RESULTS, progressive_call_results, false);
  }
  #[inline]
  pub fn add_payload_transparency(&mut self, payload_transparency: bool) {
    self.fbb_.push_slot::<bool>(CallerFeatures::VT_PAYLOAD_TRANSPARENCY, payload_transparency, false);
  }
  #[inline]
  pub fn add_payload_encryption_cryptobox(&mut self, payload_encryption_cryptobox: bool) {
    self.fbb_.push_slot::<bool>(CallerFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, payload_encryption_cryptobox, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CallerFeaturesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CallerFeaturesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CallerFeatures<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CallerFeatures<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CallerFeatures");
      ds.field("caller_identification", &self.caller_identification());
      ds.field("call_timeout", &self.call_timeout());
      ds.field("call_canceling", &self.call_canceling());
      ds.field("progressive_call_results", &self.progressive_call_results());
      ds.field("payload_transparency", &self.payload_transparency());
      ds.field("payload_encryption_cryptobox", &self.payload_encryption_cryptobox());
      ds.finish()
  }
}
pub enum CalleeFeaturesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CalleeFeatures<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CalleeFeatures<'a> {
  type Inner = CalleeFeatures<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> CalleeFeatures<'a> {
  pub const VT_CALLER_IDENTIFICATION: flatbuffers::VOffsetT = 4;
  pub const VT_CALL_TRUSTLEVELS: flatbuffers::VOffsetT = 6;
  pub const VT_CALL_TIMEOUT: flatbuffers::VOffsetT = 8;
  pub const VT_CALL_CANCELING: flatbuffers::VOffsetT = 10;
  pub const VT_PROGRESSIVE_CALL_RESULTS: flatbuffers::VOffsetT = 12;
  pub const VT_REGISTRATION_REVOCATION: flatbuffers::VOffsetT = 14;
  pub const VT_PATTERN_BASED_REGISTRATION: flatbuffers::VOffsetT = 16;
  pub const VT_SHARED_REGISTRATION: flatbuffers::VOffsetT = 18;
  pub const VT_PAYLOAD_TRANSPARENCY: flatbuffers::VOffsetT = 20;
  pub const VT_PAYLOAD_ENCRYPTION_CRYPTOBOX: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CalleeFeatures { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CalleeFeaturesArgs
  ) -> flatbuffers::WIPOffset<CalleeFeatures<'bldr>> {
    let mut builder = CalleeFeaturesBuilder::new(_fbb);
    builder.add_payload_encryption_cryptobox(args.payload_encryption_cryptobox);
    builder.add_payload_transparency(args.payload_transparency);
    builder.add_shared_registration(args.shared_registration);
    builder.add_pattern_based_registration(args.pattern_based_registration);
    builder.add_registration_revocation(args.registration_revocation);
    builder.add_progressive_call_results(args.progressive_call_results);
    builder.add_call_canceling(args.call_canceling);
    builder.add_call_timeout(args.call_timeout);
    builder.add_call_trustlevels(args.call_trustlevels);
    builder.add_caller_identification(args.caller_identification);
    builder.finish()
  }


  #[inline]
  pub fn caller_identification(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_CALLER_IDENTIFICATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn call_trustlevels(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_CALL_TRUSTLEVELS, Some(false)).unwrap()
  }
  #[inline]
  pub fn call_timeout(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_CALL_TIMEOUT, Some(false)).unwrap()
  }
  #[inline]
  pub fn call_canceling(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_CALL_CANCELING, Some(false)).unwrap()
  }
  #[inline]
  pub fn progressive_call_results(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_PROGRESSIVE_CALL_RESULTS, Some(false)).unwrap()
  }
  #[inline]
  pub fn registration_revocation(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_REGISTRATION_REVOCATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn pattern_based_registration(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_PATTERN_BASED_REGISTRATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn shared_registration(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_SHARED_REGISTRATION, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_transparency(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_PAYLOAD_TRANSPARENCY, Some(false)).unwrap()
  }
  #[inline]
  pub fn payload_encryption_cryptobox(&self) -> bool {
    self._tab.get::<bool>(CalleeFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for CalleeFeatures<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("caller_identification", Self::VT_CALLER_IDENTIFICATION, false)?
     .visit_field::<bool>("call_trustlevels", Self::VT_CALL_TRUSTLEVELS, false)?
     .visit_field::<bool>("call_timeout", Self::VT_CALL_TIMEOUT, false)?
     .visit_field::<bool>("call_canceling", Self::VT_CALL_CANCELING, false)?
     .visit_field::<bool>("progressive_call_results", Self::VT_PROGRESSIVE_CALL_RESULTS, false)?
     .visit_field::<bool>("registration_revocation", Self::VT_REGISTRATION_REVOCATION, false)?
     .visit_field::<bool>("pattern_based_registration", Self::VT_PATTERN_BASED_REGISTRATION, false)?
     .visit_field::<bool>("shared_registration", Self::VT_SHARED_REGISTRATION, false)?
     .visit_field::<bool>("payload_transparency", Self::VT_PAYLOAD_TRANSPARENCY, false)?
     .visit_field::<bool>("payload_encryption_cryptobox", Self::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, false)?
     .finish();
    Ok(())
  }
}
pub struct CalleeFeaturesArgs {
    pub caller_identification: bool,
    pub call_trustlevels: bool,
    pub call_timeout: bool,
    pub call_canceling: bool,
    pub progressive_call_results: bool,
    pub registration_revocation: bool,
    pub pattern_based_registration: bool,
    pub shared_registration: bool,
    pub payload_transparency: bool,
    pub payload_encryption_cryptobox: bool,
}
impl<'a> Default for CalleeFeaturesArgs {
  #[inline]
  fn default() -> Self {
    CalleeFeaturesArgs {
      caller_identification: false,
      call_trustlevels: false,
      call_timeout: false,
      call_canceling: false,
      progressive_call_results: false,
      registration_revocation: false,
      pattern_based_registration: false,
      shared_registration: false,
      payload_transparency: false,
      payload_encryption_cryptobox: false,
    }
  }
}

pub struct CalleeFeaturesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CalleeFeaturesBuilder<'a, 'b> {
  #[inline]
  pub fn add_caller_identification(&mut self, caller_identification: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_CALLER_IDENTIFICATION, caller_identification, false);
  }
  #[inline]
  pub fn add_call_trustlevels(&mut self, call_trustlevels: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_CALL_TRUSTLEVELS, call_trustlevels, false);
  }
  #[inline]
  pub fn add_call_timeout(&mut self, call_timeout: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_CALL_TIMEOUT, call_timeout, false);
  }
  #[inline]
  pub fn add_call_canceling(&mut self, call_canceling: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_CALL_CANCELING, call_canceling, false);
  }
  #[inline]
  pub fn add_progressive_call_results(&mut self, progressive_call_results: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_PROGRESSIVE_CALL_RESULTS, progressive_call_results, false);
  }
  #[inline]
  pub fn add_registration_revocation(&mut self, registration_revocation: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_REGISTRATION_REVOCATION, registration_revocation, false);
  }
  #[inline]
  pub fn add_pattern_based_registration(&mut self, pattern_based_registration: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_PATTERN_BASED_REGISTRATION, pattern_based_registration, false);
  }
  #[inline]
  pub fn add_shared_registration(&mut self, shared_registration: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_SHARED_REGISTRATION, shared_registration, false);
  }
  #[inline]
  pub fn add_payload_transparency(&mut self, payload_transparency: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_PAYLOAD_TRANSPARENCY, payload_transparency, false);
  }
  #[inline]
  pub fn add_payload_encryption_cryptobox(&mut self, payload_encryption_cryptobox: bool) {
    self.fbb_.push_slot::<bool>(CalleeFeatures::VT_PAYLOAD_ENCRYPTION_CRYPTOBOX, payload_encryption_cryptobox, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CalleeFeaturesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CalleeFeaturesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CalleeFeatures<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CalleeFeatures<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CalleeFeatures");
      ds.field("caller_identification", &self.caller_identification());
      ds.field("call_trustlevels", &self.call_trustlevels());
      ds.field("call_timeout", &self.call_timeout());
      ds.field("call_canceling", &self.call_canceling());
      ds.field("progressive_call_results", &self.progressive_call_results());
      ds.field("registration_revocation", &self.registration_revocation());
      ds.field("pattern_based_registration", &self.pattern_based_registration());
      ds.field("shared_registration", &self.shared_registration());
      ds.field("payload_transparency", &self.payload_transparency());
      ds.field("payload_encryption_cryptobox", &self.payload_encryption_cryptobox());
      ds.finish()
  }
}
pub enum ClientRolesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClientRoles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClientRoles<'a> {
  type Inner = ClientRoles<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ClientRoles<'a> {
  pub const VT_PUBLISHER: flatbuffers::VOffsetT = 4;
  pub const VT_SUBSCRIBER: flatbuffers::VOffsetT = 6;
  pub const VT_CALLER: flatbuffers::VOffsetT = 8;
  pub const VT_CALLEE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ClientRoles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ClientRolesArgs<'args>
  ) -> flatbuffers::WIPOffset<ClientRoles<'bldr>> {
    let mut builder = ClientRolesBuilder::new(_fbb);
    if let Some(x) = args.callee { builder.add_callee(x); }
    if let Some(x) = args.caller { builder.add_caller(x); }
    if let Some(x) = args.subscriber { builder.add_subscriber(x); }
    if let Some(x) = args.publisher { builder.add_publisher(x); }
    builder.finish()
  }


  #[inline]
  pub fn publisher(&self) -> Option<PublisherFeatures<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<PublisherFeatures>>(ClientRoles::VT_PUBLISHER, None)
  }
  #[inline]
  pub fn subscriber(&self) -> Option<SubscriberFeatures<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<SubscriberFeatures>>(ClientRoles::VT_SUBSCRIBER, None)
  }
  #[inline]
  pub fn caller(&self) -> Option<CallerFeatures<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<CallerFeatures>>(ClientRoles::VT_CALLER, None)
  }
  #[inline]
  pub fn callee(&self) -> Option<CalleeFeatures<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<CalleeFeatures>>(ClientRoles::VT_CALLEE, None)
  }
}

impl flatbuffers::Verifiable for ClientRoles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<PublisherFeatures>>("publisher", Self::VT_PUBLISHER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SubscriberFeatures>>("subscriber", Self::VT_SUBSCRIBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CallerFeatures>>("caller", Self::VT_CALLER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CalleeFeatures>>("callee", Self::VT_CALLEE, false)?
     .finish();
    Ok(())
  }
}
pub struct ClientRolesArgs<'a> {
    pub publisher: Option<flatbuffers::WIPOffset<PublisherFeatures<'a>>>,
    pub subscriber: Option<flatbuffers::WIPOffset<SubscriberFeatures<'a>>>,
    pub caller: Option<flatbuffers::WIPOffset<CallerFeatures<'a>>>,
    pub callee: Option<flatbuffers::WIPOffset<CalleeFeatures<'a>>>,
}
impl<'a> Default for ClientRolesArgs<'a> {
  #[inline]
  fn default() -> Self {
    ClientRolesArgs {
      publisher: None,
      subscriber: None,
      caller: None,
      callee: None,
    }
  }
}

pub struct ClientRolesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ClientRolesBuilder<'a, 'b> {
  #[inline]
  pub fn add_publisher(&mut self, publisher: flatbuffers::WIPOffset<PublisherFeatures<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PublisherFeatures>>(ClientRoles::VT_PUBLISHER, publisher);
  }
  #[inline]
  pub fn add_subscriber(&mut self, subscriber: flatbuffers::WIPOffset<SubscriberFeatures<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SubscriberFeatures>>(ClientRoles::VT_SUBSCRIBER, subscriber);
  }
  #[inline]
  pub fn add_caller(&mut self, caller: flatbuffers::WIPOffset<CallerFeatures<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CallerFeatures>>(ClientRoles::VT_CALLER, caller);
  }
  #[inline]
  pub fn add_callee(&mut self, callee: flatbuffers::WIPOffset<CalleeFeatures<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CalleeFeatures>>(ClientRoles::VT_CALLEE, callee);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ClientRolesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ClientRolesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClientRoles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ClientRoles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ClientRoles");
      ds.field("publisher", &self.publisher());
      ds.field("subscriber", &self.subscriber());
      ds.field("caller", &self.caller());
      ds.field("callee", &self.callee());
      ds.finish()
  }
}
pub enum RouterRolesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RouterRoles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RouterRoles<'a> {
  type Inner = RouterRoles<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> RouterRoles<'a> {
  pub const VT_BROKER: flatbuffers::VOffsetT = 4;
  pub const VT_DEALER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RouterRoles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RouterRolesArgs<'args>
  ) -> flatbuffers::WIPOffset<RouterRoles<'bldr>> {
    let mut builder = RouterRolesBuilder::new(_fbb);
    if let Some(x) = args.dealer { builder.add_dealer(x); }
    if let Some(x) = args.broker { builder.add_broker(x); }
    builder.finish()
  }


  #[inline]
  pub fn broker(&self) -> Option<BrokerFeatures<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<BrokerFeatures>>(RouterRoles::VT_BROKER, None)
  }
  #[inline]
  pub fn dealer(&self) -> Option<DealerFeatures<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<DealerFeatures>>(RouterRoles::VT_DEALER, None)
  }
}

impl flatbuffers::Verifiable for RouterRoles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BrokerFeatures>>("broker", Self::VT_BROKER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DealerFeatures>>("dealer", Self::VT_DEALER, false)?
     .finish();
    Ok(())
  }
}
pub struct RouterRolesArgs<'a> {
    pub broker: Option<flatbuffers::WIPOffset<BrokerFeatures<'a>>>,
    pub dealer: Option<flatbuffers::WIPOffset<DealerFeatures<'a>>>,
}
impl<'a> Default for RouterRolesArgs<'a> {
  #[inline]
  fn default() -> Self {
    RouterRolesArgs {
      broker: None,
      dealer: None,
    }
  }
}

pub struct RouterRolesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RouterRolesBuilder<'a, 'b> {
  #[inline]
  pub fn add_broker(&mut self, broker: flatbuffers::WIPOffset<BrokerFeatures<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BrokerFeatures>>(RouterRoles::VT_BROKER, broker);
  }
  #[inline]
  pub fn add_dealer(&mut self, dealer: flatbuffers::WIPOffset<DealerFeatures<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DealerFeatures>>(RouterRoles::VT_DEALER, dealer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RouterRolesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RouterRolesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RouterRoles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RouterRoles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RouterRoles");
      ds.field("broker", &self.broker());
      ds.field("dealer", &self.dealer());
      ds.finish()
  }
}
}  // pub mod proto
}  // pub mod wamp

